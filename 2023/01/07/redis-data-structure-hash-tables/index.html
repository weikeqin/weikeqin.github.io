<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"weikeqin.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="哈希表是一种非常关键的数据结构，在计算机系统中发挥着重要作用。  它的底层是数组+链表，通过哈希计算，能以 O(1) 的复杂度快速根据key查询到数据。 (1) 数据结构-哈希表  假设让我们自己实现一个哈希表，我们要考虑哪些方面？  哈希表提供的功能 哈希表操作的时间复杂度为O(1) 哈希表的容量与扩容">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis里的哈希表">
<meta property="og:url" content="http://weikeqin.com/2023/01/07/redis-data-structure-hash-tables/index.html">
<meta property="og:site_name" content="天道酬勤">
<meta property="og:description" content="哈希表是一种非常关键的数据结构，在计算机系统中发挥着重要作用。  它的底层是数组+链表，通过哈希计算，能以 O(1) 的复杂度快速根据key查询到数据。 (1) 数据结构-哈希表  假设让我们自己实现一个哈希表，我们要考虑哪些方面？  哈希表提供的功能 哈希表操作的时间复杂度为O(1) 哈希表的容量与扩容">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-07T12:39:57.000Z">
<meta property="article:modified_time" content="2023-01-27T15:20:59.499Z">
<meta property="article:author" content="WKQ">
<meta property="article:tag" content="database">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://weikeqin.com/2023/01/07/redis-data-structure-hash-tables/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://weikeqin.com/2023/01/07/redis-data-structure-hash-tables/","path":"2023/01/07/redis-data-structure-hash-tables/","title":"Redis里的哈希表"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis里的哈希表 | 天道酬勤</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113485469-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-113485469-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?d1ad0ae2a9976c44d556abc07cda1365"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">天道酬勤</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">(1) 数据结构-哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">1.1.</span> <span class="nav-text">(1.1) 提供的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1"><span class="nav-number">1.2.</span> <span class="nav-text">(1.2) 时间复杂度O(1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%B9%E9%87%8F%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="nav-number">1.3.</span> <span class="nav-text">(1.3) 哈希表容量与扩容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Redis%E9%87%8C%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">(2) Redis里的哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">(2.1) 哈希表结构定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">2.2.</span> <span class="nav-text">(2.2) 哈希表提供的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">(2.2.1) 创建一个哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.2.</span> <span class="nav-text">(2.2.2) 哈希表添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.3.</span> <span class="nav-text">(2.2.3) 哈希表更新元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.4.</span> <span class="nav-text">(2.2.4) 哈希表查找元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.5.</span> <span class="nav-text">(2.2.5) 哈希表删除元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%89%A9%E5%AE%B9"><span class="nav-number">2.3.</span> <span class="nav-text">(2.3) 哈希表扩容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-rehash"><span class="nav-number">3.</span> <span class="nav-text">(3) rehash</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-rehash%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9Frehash"><span class="nav-number">3.1.</span> <span class="nav-text">(3.1) rehash的触发条件-什么时候发生rehash</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E9%87%8C%E8%B0%83%E7%94%A8%E4%BA%86-dictExpandIfNeeded"><span class="nav-number">3.1.1.</span> <span class="nav-text">在哪些函数里调用了_dictExpandIfNeeded</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-rehash%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">(3.2) rehash如何执行？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%B8%90%E8%BF%9B%E5%BC%8Fhash%E6%97%B6%EF%BC%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C%E5%93%AA%E4%B8%AAht"><span class="nav-number">3.3.</span> <span class="nav-text">(3.3) 渐进式hash时，增删改查操作哪个ht?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-rehash%E6%89%A9%E5%AE%B9%E5%90%8E%E6%9C%89%E5%A4%9A%E5%A4%A7-rehash%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">3.4.</span> <span class="nav-text">(3.4) rehash扩容后有多大-rehash的结果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Redis%E9%87%8C%E7%9A%84Hash%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">(4) Redis里的Hash函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WKQ</p>
  <div class="site-description" itemprop="description">不积跬步无以至千里</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">296</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:weikeqin.cn@gmail.com" title="E-Mail → mailto:weikeqin.cn@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/u/0/107737814703120725006" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;u&#x2F;0&#x2F;107737814703120725006" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/wkq278276130" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;wkq278276130" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/keqin.wei.5" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;keqin.wei.5" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/8054088/wkq" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;8054088&#x2F;wkq" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weikeqin.com/2023/01/07/redis-data-structure-hash-tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WKQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天道酬勤">
      <meta itemprop="description" content="不积跬步无以至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis里的哈希表 | 天道酬勤">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis里的哈希表
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-07 20:39:57" itemprop="dateCreated datePublished" datetime="2023-01-07T20:39:57+08:00">2023-01-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-27 23:20:59" itemprop="dateModified" datetime="2023-01-27T23:20:59+08:00">2023-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>  哈希表是一种非常关键的数据结构，在计算机系统中发挥着重要作用。<br>  它的底层是数组+链表，通过哈希计算，能以 O(1) 的复杂度快速根据key查询到数据。</p>
<h1 id="1-数据结构-哈希表"><a href="#1-数据结构-哈希表" class="headerlink" title="(1) 数据结构-哈希表"></a>(1) 数据结构-哈希表</h1><p>  假设让我们自己实现一个哈希表，我们要考虑哪些方面？</p>
<ol>
<li>哈希表提供的功能</li>
<li>哈希表操作的时间复杂度为O(1)</li>
<li>哈希表的容量与扩容</li>
</ol>
<span id="more"></span>

<h2 id="1-1-提供的功能"><a href="#1-1-提供的功能" class="headerlink" title="(1.1) 提供的功能"></a>(1.1) 提供的功能</h2><p>  新建哈希表、新增数据、修改数据、删除数据、查询数据</p>
<br>

<h2 id="1-2-时间复杂度O-1"><a href="#1-2-时间复杂度O-1" class="headerlink" title="(1.2) 时间复杂度O(1)"></a>(1.2) 时间复杂度O(1)</h2><p>  要想使时间复杂度为O(1)，要通过高效的定位方法，比如hash函数<br>  但是hash函数有个问题，可能会哈希冲突，冲突后有多种方法 <code>链地址法</code>、 <code>开放定位法</code>、 <code>再哈希法</code>，这里我们使用链地址法实现。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** 哈希函数 */</span>
<span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token comment">// h = key.hashCode() 为第一步 取hashCode值</span>
    <span class="token comment">// h ^ (h >>> 16)  为第二步 高位参与运算</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  链式哈希的链不能太长，否则会降低 哈希表性能。<br>  链表哈希的链表太长时可以转换为红黑树提高查询性能。</p>
<br>

<h2 id="1-3-哈希表容量与扩容"><a href="#1-3-哈希表容量与扩容" class="headerlink" title="(1.3) 哈希表容量与扩容"></a>(1.3) 哈希表容量与扩容</h2><p>  这里我们在创建哈希表的时候支持指定容量<br>  扩容时容量是原来的2倍</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p>  如果容量特别大，内存不够怎么办？</p>
<br>


<h1 id="2-Redis里的哈希表"><a href="#2-Redis里的哈希表" class="headerlink" title="(2) Redis里的哈希表"></a>(2) Redis里的哈希表</h1><p>  对于 Redis 键值数据库来说，哈希表既是键值对中的一种值类型，同时，Redis 也使用一个全局 哈希表来保存所有的键值对，从而既满足应用存取 Hash 结构数据需求，又能提供快速查询功能。</p>
<p>  在实际应用 哈希表时，当数据量不断增加，它的性能就经常会受到<code>哈希冲突</code>和 <code>rehash</code> 开销的影响。</p>
<p>  针对哈希冲突，Redis 采用了链式哈希，在不扩容哈希表的前提下，将具有相同哈希值的数据链接起来，以便这些数据在表中仍然可以被查询到；<br>  对于 rehash 开销，Redis 实现了渐进式 rehash 设计，进而缓解了 rehash 操作带来的额外开销对系统的性能影响。</p>
<p>  <code>dict.h</code> 文件定义了 哈希表的结构、哈希项，以及 哈希表的各种操作函数，<br>  <code>dict.c</code> 文件包含了 哈希表各种操作的具体实现代码。  </p>
<p>  源码  <a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/6.0/src/dict.h">https://github.com/redis/redis/blob/6.0/src/dict.h</a><br>       <a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/6.0/src/dict.c">https://github.com/redis/redis/blob/6.0/src/dict.c</a></p>
<br>

<h2 id="2-1-哈希表结构定义"><a href="#2-1-哈希表结构定义" class="headerlink" title="(2.1) 哈希表结构定义"></a>(2.1) 哈希表结构定义</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** 
 * 这是哈希表结构。
 * 每个字典都有两个这样的字典，因为我们实现了增量重新哈希，从旧表到新表。 
 *&#x2F;
typedef struct dictht &#123;
    dictEntry **table;  &#x2F;&#x2F; 一维数组的指针
    unsigned long size;  &#x2F;&#x2F; 哈希表大小
    unsigned long sizemask;  &#x2F;&#x2F; size-1 &#x3D; (2^n - 1)，比2^n少1，用于计算key对应桶的下标
    unsigned long used;  &#x2F;&#x2F; 已使用个数
&#125; dictht;


&#x2F;**
 * 哈希表节点
 *&#x2F;
typedef struct dictEntry &#123;
    void *key; &#x2F;&#x2F; key的指针
    union &#123;
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    &#125; v;  &#x2F;&#x2F; value  联合结构体(不同场景使用不同大小，省内存)
    struct dictEntry *next; &#x2F;&#x2F; 链表的下一个节点的指针
&#125; dictEntry;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  可以看到 哈希表<code>dictht</code>里定义了 二维数组()、哈希表大小、<br>  哈希节点里定义了 键(key)、值(v)、链表的下一个节点(next)，其中值(v)是一个联合体，联合体中包含了指向实际值的指针 *val，还包含了无符号的 64 位整数、有符号的 64 位整数，以及 double 类的值。</p>
<p>  为什么要使用联合体呢？<br>  这种实现方法是一种节省内存的小技巧，因为当值为整数或双精度浮点数时，由于其本身就是64位，就可以不用指针指向了，而是可以直接存在键值对的结构体中，这样就避免了再用一个指针，从而节省了内存空间。</p>
<br>


<h2 id="2-2-哈希表提供的功能"><a href="#2-2-哈希表提供的功能" class="headerlink" title="(2.2) 哈希表提供的功能"></a>(2.2) 哈希表提供的功能</h2><table>
<thead>
<tr>
<th>操作</th>
<th>函数</th>
<th>算法复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>创建一个新字典</td>
<td>dictCreate</td>
<td>O(1)</td>
</tr>
<tr>
<td>添加新键值对到字典</td>
<td>dictAdd</td>
<td>O(1)</td>
</tr>
<tr>
<td>添加或更新给定键的值</td>
<td>dictReplace</td>
<td>O(1)</td>
</tr>
<tr>
<td>在字典中查找给定键所在的节点</td>
<td>dictFind</td>
<td>O(1)</td>
</tr>
<tr>
<td>在字典中查找给定键的值</td>
<td>dictFetchValue</td>
<td>O(1)</td>
</tr>
<tr>
<td>从字典中随机返回一个节点</td>
<td>dictGetRandomKey</td>
<td>O(1)</td>
</tr>
<tr>
<td>根据给定键，删除字典中的键值对</td>
<td>dictDelete</td>
<td>O(1)</td>
</tr>
<tr>
<td>清空并释放字典</td>
<td>dictRelease</td>
<td>O(N)</td>
</tr>
<tr>
<td>清空并重置（但不释放）字典</td>
<td>dictEmpty</td>
<td>O(N)</td>
</tr>
<tr>
<td>缩小字典</td>
<td>dictResize</td>
<td>O(N)</td>
</tr>
<tr>
<td>扩大字典</td>
<td>dictExpand</td>
<td>O(N)</td>
</tr>
<tr>
<td>对字典进行给定步数的 rehash</td>
<td>dictRehash</td>
<td>O(N)</td>
</tr>
<tr>
<td>在给定毫秒内，对字典进行rehash</td>
<td>dictRehashMilliseconds</td>
<td>O(N)</td>
</tr>
</tbody></table>
<br>


<h3 id="2-2-1-创建一个哈希表"><a href="#2-2-1-创建一个哈希表" class="headerlink" title="(2.2.1) 创建一个哈希表"></a>(2.2.1) 创建一个哈希表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** 创建一个新的哈希表 *&#x2F;
dict *dictCreate(dictType *type,
        void *privDataPtr)
&#123;
    &#x2F;&#x2F; 分配内存
    dict *d &#x3D; zmalloc(sizeof(*d));
    &#x2F;&#x2F; 初始化
    _dictInit(d,type,privDataPtr);
    return d;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** 初始化哈希表 *&#x2F;
int _dictInit(dict *d, dictType *type,
        void *privDataPtr)
&#123;
    _dictReset(&amp;d-&gt;ht[0]); &#x2F;&#x2F; 重置ht[0]
    _dictReset(&amp;d-&gt;ht[1]); &#x2F;&#x2F; 重置ht[1]
    d-&gt;type &#x3D; type; &#x2F;&#x2F; 设置哈希表类型
    d-&gt;privdata &#x3D; privDataPtr; &#x2F;&#x2F; 
    d-&gt;rehashidx &#x3D; -1; &#x2F;&#x2F; 设置成-1 代表没有进行rehash
    d-&gt;iterators &#x3D; 0; &#x2F;&#x2F; 
    return DICT_OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** 重置已经初始化的哈希表
 * NOTE: This function should only be called by ht_destroy(). *&#x2F;
static void _dictReset(dictht *ht)
&#123;
    ht-&gt;table &#x3D; NULL; &#x2F;&#x2F; 哈希表的数组置为null
    ht-&gt;size &#x3D; 0; &#x2F;&#x2F; 哈希表长度设置为0
    ht-&gt;sizemask &#x3D; 0; &#x2F;&#x2F; 掩码设置为0
    ht-&gt;used &#x3D; 0; &#x2F;&#x2F; 已使用空间设置为0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>


<h3 id="2-2-2-哈希表添加元素"><a href="#2-2-2-哈希表添加元素" class="headerlink" title="(2.2.2) 哈希表添加元素"></a>(2.2.2) 哈希表添加元素</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: dict.c

&#x2F;** 
 * 往哈希表添加一个元素
 * 
 * @param *d
 * @param *key
 * @param *val
 *&#x2F;
int dictAdd(dict *d, void *key, void *val)
&#123;
    &#x2F;&#x2F; 创建哈希节点 并设置key  (这个时候没有往哈希表设置val)
    dictEntry *entry &#x3D; dictAddRaw(d,key,NULL);

    if (!entry) return DICT_ERR;
    &#x2F;&#x2F; 哈希表设置val
    dictSetVal(d, entry, val);
    return DICT_OK;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 
 *  低级添加或查找：
 *  此函数添加条目但不是设置值，而是将 dictEntry 结构返回给用户，这将确保按照他的意愿填充值字段。
 *
 *  这个函数也是直接暴露给用户API调用的，主要是为了在hash值里面存储非指针，例如：
 *
 *    entry &#x3D; dictAddRaw(dict,mykey,NULL);
 *    if (entry !&#x3D; NULL) dictSetSignedIntegerVal(entry,1000);
 *
 *  返回值：
 *    如果键已经存在，则返回 NULL，如果 existing 不为 NULL，则“*existing”将填充现有条目。
 *    如果添加了键，则返回哈希条目以供调用者操作。
 *&#x2F;
dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
&#123;
    long index;
    dictEntry *entry;
    dictht *ht;

    &#x2F;&#x2F; 如果正在rehash，进行rehash   这里只迁移一个桶，几乎对性能无影响
    if (dictIsRehashing(d)) _dictRehashStep(d);

    &#x2F;&#x2F; 获取元素下标  如果元素已经存在返回-1 
    if ((index &#x3D; _dictKeyIndex(d, key, dictHashKey(d,key), existing)) &#x3D;&#x3D; -1)
        return NULL;

    &#x2F;* 分配内存并存储新条目。
     * 在顶部插入元素，假设在数据库系统中，最近添加的条目更有可能被更频繁地访问。*&#x2F;

    &#x2F;&#x2F; 如果在进行rehash，往ht[1]里添加元素 
    ht &#x3D; dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];
    &#x2F;&#x2F; 为新节点分配内存
    entry &#x3D; zmalloc(sizeof(*entry));
    &#x2F;&#x2F; 把新节点插入到链表的头部
    entry-&gt;next &#x3D; ht-&gt;table[index];
    &#x2F;&#x2F; 更新链表头结点
    ht-&gt;table[index] &#x3D; entry;
    &#x2F;&#x2F; 哈希表已使用节点数+1
    ht-&gt;used++;

    &#x2F;* Set the hash entry fields. *&#x2F;
    dictSetKey(d, entry, key);
    return entry;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file:  dict.h

&#x2F;** 设置key *&#x2F;
#define dictSetKey(d, entry, _key_) do &#123; \
    if ((d)-&gt;type-&gt;keyDup) \
        (entry)-&gt;key &#x3D; (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \
    else \
        (entry)-&gt;key &#x3D; (_key_); \
&#125; while(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file:  dict.h

&#x2F;** 设置val *&#x2F;
#define dictSetVal(d, entry, _val_) do &#123; \
    if ((d)-&gt;type-&gt;valDup) \
        (entry)-&gt;v.val &#x3D; (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \
    else \
        (entry)-&gt;v.val &#x3D; (_val_); \
&#125; while(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>

<h3 id="2-2-3-哈希表更新元素"><a href="#2-2-3-哈希表更新元素" class="headerlink" title="(2.2.3) 哈希表更新元素"></a>(2.2.3) 哈希表更新元素</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * 添加或覆盖：
 *  添加一个元素，如果键已经存在则丢弃旧值。
 *  如果该键是从头开始添加的，则返回 1，
 *  如果已经存在具有该键的元素，则返回 0，并且 dictReplace() 刚刚执行了值更新操作。
 *&#x2F;
int dictReplace(dict *d, void *key, void *val)
&#123;
    dictEntry *entry, *existing, auxentry;

    &#x2F;&#x2F; 添加条目
    entry &#x3D; dictAddRaw(d,key,&amp;existing);
    if (entry) &#123;
        &#x2F;&#x2F; 设置值
        dictSetVal(d, entry, val);
        return 1;
    &#125;

    &#x2F;* 设置新值并释放旧值。 
     * 请注意，按此顺序执行此操作很重要，因为值可能与前一个值完全相同。 
     * 在这种情况下，想想引用计数，你想要递增（设置），然后递减（自由），而不是相反。
     *&#x2F;
    auxentry &#x3D; *existing;
    &#x2F;&#x2F; 覆盖值
    dictSetVal(d, existing, val);
    &#x2F;&#x2F; 释放原来的
    dictFreeVal(d, &amp;auxentry);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>

<h3 id="2-2-4-哈希表查找元素"><a href="#2-2-4-哈希表查找元素" class="headerlink" title="(2.2.4) 哈希表查找元素"></a>(2.2.4) 哈希表查找元素</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * 
 * @param *d
 * @param *key
 *&#x2F;
dictEntry *dictFind(dict *d, const void *key)
&#123;
    dictEntry *he;
    uint64_t h, idx, table;

    &#x2F;&#x2F; 字典是空的，字典里两个哈希表都是空的 
    if (dictSize(d) &#x3D;&#x3D; 0) return NULL; &#x2F;* dict is empty *&#x2F;
    &#x2F;&#x2F; 哈希表正在rehash，执行rehash
    if (dictIsRehashing(d)) _dictRehashStep(d);
    &#x2F;&#x2F; 计算key的hash
    h &#x3D; dictHashKey(d, key);
    &#x2F;&#x2F; 有2个哈希表 ht[0] ht[1]，有可能正在rehash，所以都要查，对应代码是 table&#x3D;0 table&lt;&#x3D;1 
    for (table &#x3D; 0; table &lt;&#x3D; 1; table++) &#123;
        &#x2F;&#x2F; 获取数组索引下标
        idx &#x3D; h &amp; d-&gt;ht[table].sizemask;
        &#x2F;&#x2F; 桶&#x2F;链表头结点
        he &#x3D; d-&gt;ht[table].table[idx];
        &#x2F;&#x2F; 遍历链表
        while(he) &#123;
            &#x2F;&#x2F; key相同 或 key对比相等
            if (key&#x3D;&#x3D;he-&gt;key || dictCompareKeys(d, key, he-&gt;key))
                return he; &#x2F;&#x2F; 返回对应节点
            he &#x3D; he-&gt;next;
        &#125;
        if (!dictIsRehashing(d)) return NULL;
    &#125;
    return NULL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>

<h3 id="2-2-5-哈希表删除元素"><a href="#2-2-5-哈希表删除元素" class="headerlink" title="(2.2.5) 哈希表删除元素"></a>(2.2.5) 哈希表删除元素</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** 
 * 删除一个元素
 * 成功时返回 DICT_OK，如果找不到该元素则返回 DICT_ERR。 
 * 
 * @param *ht
 * @param *key
 *&#x2F;
int dictDelete(dict *ht, const void *key) &#123;
    return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * 搜索并删除元素。
 * 这是 dictDelete() 和 dictUnlink()的辅助函数，请检查这些函数的顶部注释。
 * 
 * @param *d
 * @param *key 
 * @param nofree 
 *&#x2F;
static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) &#123;
    uint64_t h, idx;
    dictEntry *he, *prevHe;
    int table;

    &#x2F;&#x2F; ht[0] ht[1] 已使用大小为0，返回null
    if (d-&gt;ht[0].used &#x3D;&#x3D; 0 &amp;&amp; d-&gt;ht[1].used &#x3D;&#x3D; 0) return NULL;

    &#x2F;&#x2F; 如果正在rehash，执行rehash
    if (dictIsRehashing(d)) _dictRehashStep(d);
    &#x2F;&#x2F; 获取hash值
    h &#x3D; dictHashKey(d, key);
    &#x2F;&#x2F; ht[0] ht[1] 都会查，所以 table&#x3D;0 table&lt;&#x3D;1 
    for (table &#x3D; 0; table &lt;&#x3D; 1; table++) &#123;
        &#x2F;&#x2F; 获取下标
        idx &#x3D; h &amp; d-&gt;ht[table].sizemask;
        &#x2F;&#x2F; 获取桶
        he &#x3D; d-&gt;ht[table].table[idx];
        prevHe &#x3D; NULL;
        &#x2F;&#x2F; 遍历链表
        while(he) &#123;
            if (key&#x3D;&#x3D;he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;
                &#x2F;* Unlink the element from the list *&#x2F;
                if (prevHe)
                    prevHe-&gt;next &#x3D; he-&gt;next; &#x2F;&#x2F; 移除链表里的当前节点
                else
                    d-&gt;ht[table].table[idx] &#x3D; he-&gt;next; &#x2F;&#x2F; 设置next节点为头结点，next有可能是null
                if (!nofree) &#123;
                    &#x2F;&#x2F; 释放key
                    dictFreeKey(d, he);
                    &#x2F;&#x2F; 释放val
                    dictFreeVal(d, he);
                    &#x2F;&#x2F; 释放entry
                    zfree(he);
                &#125;
                &#x2F;&#x2F; 更新使用元素个数
                d-&gt;ht[table].used--;
                return he;
            &#125;
            &#x2F;&#x2F; 更新前驱节点
            prevHe &#x3D; he;
            &#x2F;&#x2F; 处理下一个节点
            he &#x3D; he-&gt;next;
        &#125;
        if (!dictIsRehashing(d)) break;
    &#125;

    &#x2F;&#x2F; 没有找到key
    return NULL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>

<h2 id="2-3-哈希表扩容"><a href="#2-3-哈希表扩容" class="headerlink" title="(2.3) 哈希表扩容"></a>(2.3) 哈希表扩容</h2><p>  哈希表扩容是指 rehash 操作，其实就是指扩大 哈希表空间。</p>
<p>Redis rehash流程</p>
<ol>
<li>Redis里保存了两个 Hash表 <code>ht[0]</code>和 <code>ht[1]</code>，用于 rehash 时交替保存数据；</li>
<li>在正常服务请求阶段，所有的键值对写入哈希表 ht[0]；</li>
<li>当进行 rehash 时，键值对被迁移到哈希表 ht[1]中；</li>
<li>当迁移完成后，ht[0]的空间会被释放，并把 ht[1]的地址赋值给 ht[0]，ht[1]的表大小设置为 0</li>
</ol>
<p>  这样一来，又回到了正常服务请求的阶段，ht[0]接收和服务请求，ht[1]作为下一次 rehash 时的迁移表。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct dict &#123;
    dictType *type; &#x2F;&#x2F; 类型
    void *privdata; &#x2F;&#x2F;
    dictht ht[2]; &#x2F;&#x2F; 2个哈希表
    long rehashidx; &#x2F;&#x2F; rehashidx &#x3D;&#x3D; -1 则rehashing没有进行  
    unsigned long iterators; &#x2F;&#x2F; 当前正在运行的迭代器数
&#125; dict;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  在rehashing时，<code>rehashidx</code>对应要操作的 <code>ht[0].table[rehashidx]</code> 的桶</p>
<br>


<h1 id="3-rehash"><a href="#3-rehash" class="headerlink" title="(3) rehash"></a>(3) rehash</h1><p>  rehash的整体流程<br>  在</p>
<h2 id="3-1-rehash的触发条件-什么时候发生rehash"><a href="#3-1-rehash的触发条件-什么时候发生rehash" class="headerlink" title="(3.1) rehash的触发条件-什么时候发生rehash"></a>(3.1) rehash的触发条件-什么时候发生rehash</h2><ol>
<li><p>在哈希表为空时，调用<code>_dictExpandIfNeeded</code>会触发哈希表初始化，默认大小为4。</p>
</li>
<li><p>在哈希表不为空时，触发rehash需要同时满足2个条件:</p>
</li>
</ol>
<ul>
<li>已使用桶数量:哈希表桶容量 达到了 1:1 的比例 (<code>ht[0].used &gt; ht[0].size</code>)</li>
<li>允许调整哈希表的大小(<code>dict_can_resize=1</code>) 或者 元素/桶 &gt; 5 (<code>dict_force_resize_ratio&gt;5</code>)</li>
</ul>
<p>  具体代码如下:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: dict.c 

&#x2F;** 
 * 如果需要扩展哈希表
 *
 * @param *d
 *&#x2F;
static int _dictExpandIfNeeded(dict *d)
&#123;
    &#x2F;&#x2F; 增量rehash正在进行中，返回   通过 rehashidx !&#x3D; -1 判断
    if (dictIsRehashing(d)) return DICT_OK;

    &#x2F;&#x2F; 如果哈希表为空，则将其扩展到初始大小。 初始大小默认为4 
    if (d-&gt;ht[0].size &#x3D;&#x3D; 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    &#x2F;* 
     * 如果 已使用桶数量:哈希表桶容量 达到了 1:1 的比例，
     * 并且我们被允许调整哈希表的大小(全局设置) 或者 应该避免它但是元素&#x2F;桶之间的比例超过了“安全”阈值 5 ，
     * 我们调整大小使桶的数量为原来2倍。
     * 
     * If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements&#x2F;buckets is over the &quot;safe&quot; threshold, we resize doubling
     * the number of buckets. *&#x2F;
    if (d-&gt;ht[0].used &gt;&#x3D; d-&gt;ht[0].size &amp;&amp;
        (dict_can_resize ||
         d-&gt;ht[0].used&#x2F;d-&gt;ht[0].size &gt; dict_force_resize_ratio))  &#x2F;&#x2F; dict_force_resize_ratio 默认为5 
    &#123;
        &#x2F;&#x2F; 扩容
        return dictExpand(d, d-&gt;ht[0].used*2);
    &#125;
    return DICT_OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>dict_can_resize</code> 变量值默认是1，可以在 <code>dictEnableResize</code>、 <code>dictDisableResize</code> 函数中设置</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: dict.c 

&#x2F;* 
 * 使用 dictEnableResize() &#x2F; dictDisableResize() 我们可以根据需要启用&#x2F;禁用哈希表的大小调整。 
 * 这对 Redis 来说非常重要，因为我们使用写时复制，并且不想在有子进程正在执行保存操作时移动太多内存。
 *
 * 请注意，即使将 dict_can_resize 设置为 0，也不会阻止所有调整大小：
 *   如果元素数量与桶数之间的比率 &gt; dict_force_resize_ratio，则哈希表仍然允许增长。
 *&#x2F;
static int dict_can_resize &#x3D; 1;

void dictEnableResize(void) &#123;
    dict_can_resize &#x3D; 1;
&#125;

void dictDisableResize(void) &#123;
    dict_can_resize &#x3D; 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>dict_force_resize_ratio</code> 值在 <code>dict.c</code> 文件中定义，默认是5</p>
<h3 id="在哪些函数里调用了-dictExpandIfNeeded"><a href="#在哪些函数里调用了-dictExpandIfNeeded" class="headerlink" title="在哪些函数里调用了_dictExpandIfNeeded"></a>在哪些函数里调用了_dictExpandIfNeeded</h3><p> <code>_dictExpandIfNeeded</code> 是被 <code>_dictKeyIndex</code> 函数调用的<br> <code>_dictKeyIndex</code> 函数又会被 <code>dictAddRaw</code> 函数调用<br> <code>dictAddRaw</code> 会被 <code>dictAdd</code> <code>dictRelace</code> <code>dictAddorFind</code> <code>sentinelLeaderIncr</code> <code>setTypeAdd</code> <code>zunionInterGenericCommand</code> 函数调用</p>
<p>  当我们往 Redis 中写入新的键值对或是修改键值对时，Redis 都会判断下是否需要进行 rehash。<br>  这里你可以参考下面给出的示意图，其中就展示了 _dictExpandIfNeeded 被调用的关系。</p>
<p>  <img src=""></p>
<br>


<h2 id="3-2-rehash如何执行？"><a href="#3-2-rehash如何执行？" class="headerlink" title="(3.2) rehash如何执行？"></a>(3.2) rehash如何执行？</h2><p>  为什么要实现渐进式rehash？</p>
<p>  因为哈希表在执行rehash时，由于哈希表扩容，key对应的位置会改变，很多key就需要从原来的位置复制到新的位置。<br>  而在键复制时，由于Redis主线程无法执行其他请求，会阻塞主线程，如果要复制的键特别多，Redis在执行哈希表扩容时，此时Redis Server对外是不可用的，这个是我们不能接受的。</p>
<p>  为了避免Redis Server在哈希表扩容时不可用，提出了渐进式 rehash 的方法。<br>  相当于把一次要干的很多事情分成多次要做的小事情。 把一次要复制的100万个key 转换为 10万次每次复制10个key，这样既不影响其他请求，也把哈希表扩容了。</p>
<p>渐进式rehash在代码层面是如何实现的呢？<br>  有两个关键函数：<code>dictRehash</code> 和 <code>_dictRehashStep</code>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 
 * 执行N步增量rehashing。 
 * 如果仍有键从旧哈希表移动到新哈希表，则返回 1，否则返回 0。
 *
 * 请注意，重新散列步骤包括将一个桶(在使用链表时可能有不止一个键)从旧哈希表移动到新哈希表，
 * 但是由于哈希表的一部分可能由空白组成，因此不能保证 这个函数甚至会重新散列一个桶，
 * 因为它总共最多访问 N*10 个空桶，避免它所做的工作量将不受限制，并且该函数可能会阻塞很长时间。
 *
 * @param *d
 * @param n
 *&#x2F;
int dictRehash(dict *d, int n) &#123;
    int empty_visits &#x3D; n*10; &#x2F;&#x2F; 最多访问10倍的空桶 一个桶对应一个数组下标
    &#x2F;&#x2F; 如果哈希表没有进行rehashing 返回0
    if (!dictIsRehashing(d)) return 0;
    
    &#x2F;&#x2F; 循环
    &#x2F;&#x2F; n&gt;0 并且 哈希表里已使用元素 &gt; 0 时，进行
    while(n-- &amp;&amp; d-&gt;ht[0].used !&#x3D; 0) &#123;
        dictEntry *de, *nextde;

        &#x2F;&#x2F; 避免ht[0]数组下标越界 
        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);

        &#x2F;&#x2F; 哈希表ht[0]对应数组下标的元素为null 也就是 桶对应的元素为null
        while(d-&gt;ht[0].table[d-&gt;rehashidx] &#x3D;&#x3D; NULL) &#123;
            &#x2F;&#x2F; 全局rehashidx+1  这里的rehashidx 就是要操作的 ht[0].table的下标对应的桶
            d-&gt;rehashidx++;
            if (--empty_visits &#x3D;&#x3D; 0) return 1;
        &#125;
        &#x2F;&#x2F; 获取ht[0].table[rehashidx] 对应的桶
        de &#x3D; d-&gt;ht[0].table[d-&gt;rehashidx];

        &#x2F;&#x2F; 反转链表-尾插法
        &#x2F;&#x2F; 遍历链表  将这个桶中的所有键从旧的ht[0] 移到新的ht[1] 
        while(de) &#123;
            uint64_t h;
            
            nextde &#x3D; de-&gt;next; &#x2F;&#x2F; 下一个链表节点
            &#x2F;&#x2F; 获取key在新ht[1]的下标
            h &#x3D; dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;
            &#x2F;&#x2F; 插入到 头节点的前面
            de-&gt;next &#x3D; d-&gt;ht[1].table[h];
            &#x2F;&#x2F; 更新桶里链表的头节点
            d-&gt;ht[1].table[h] &#x3D; de;

            d-&gt;ht[0].used--; &#x2F;&#x2F; 更新ht[0]已使用个数
            d-&gt;ht[1].used++; &#x2F;&#x2F; 更新ht[1]已使用个数

            de &#x3D; nextde; &#x2F;&#x2F; 指向下一个链表节点
        &#125;
        &#x2F;&#x2F; 把ht[0].table[d-&gt;rehashidx] 对应桶的链表置空  
        d-&gt;ht[0].table[d-&gt;rehashidx] &#x3D; NULL;
        d-&gt;rehashidx++; &#x2F;&#x2F; 更新rehashidx
    &#125;

    &#x2F;&#x2F; 判断ht[0]的数据是否全部迁移完成 
    if (d-&gt;ht[0].used &#x3D;&#x3D; 0) &#123;
        &#x2F;&#x2F; 释放ht[0]内存空间
        zfree(d-&gt;ht[0].table);
        &#x2F;&#x2F; 把ht[0]指向ht[1]，以便接受正常的请求
        d-&gt;ht[0] &#x3D; d-&gt;ht[1];
        &#x2F;&#x2F; 重置ht[1]的大小为0
        _dictReset(&amp;d-&gt;ht[1]);
        &#x2F;&#x2F; 设置全局哈希表的rehashidx标识为-1，表示rehash结束
        d-&gt;rehashidx &#x3D; -1;
        &#x2F;&#x2F;返回0，表示ht[0]中所有元素都迁移完
        return 0;
    &#125;

    &#x2F;&#x2F;返回1，表示ht[0]中仍然有元素没有迁移完
    return 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * 此函数仅执行一个重新散列步骤，并且仅当没有安全迭代器绑定到我们的散列表时。 
 * 当在重新散列中间有迭代器时，不能弄乱两个散列表，否则某些元素可能会丢失或重复。
 *
 * 此函数由字典中的常见查找或更新操作调用，以便哈希表在主动使用时自动从 H1 迁移到 H2。
 *
 * @param *d
 *&#x2F;
static void _dictRehashStep(dict *d) &#123;
    &#x2F;&#x2F; rehash一个桶的数据
    if (d-&gt;iterators &#x3D;&#x3D; 0) dictRehash(d,1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 
 * 以 ms+&quot;delta&quot; 毫秒rehash。 
 * &quot;delta&quot; 的值大于0，多数情况下小于1。 
 * 确切的上限取决于 dictRehash(d,100) 的运行时间。
 * 
 * @param *d
 * @param ms
 *&#x2F;
int dictRehashMilliseconds(dict *d, int ms) &#123;
    long long start &#x3D; timeInMilliseconds(); &#x2F;&#x2F; ms时间戳
    int rehashes &#x3D; 0;
    
    while(dictRehash(d,100)) &#123; &#x2F;&#x2F; 一次rehash 100个桶
        rehashes +&#x3D; 100;
        &#x2F;&#x2F; 超过指定时间，break
        if (timeInMilliseconds()-start &gt; ms) break;
    &#125;
    return rehashes;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>dictAddRaw  -&gt; _dictRehashStep<br>dictGenericDelete -&gt; _dictRehashStep<br>dictFind -&gt; _dictRehashStep<br>dictGetRandomKey -&gt; _dictRehashStep<br>dictGetSomeKeys -&gt; _dictRehashStep </p>
<p>_dictRehashStep -&gt; dictRehash<br>incrementallyRehash -&gt; dictRehashMilliseconds -&gt; dictRehash </p>
<h2 id="3-3-渐进式hash时，增删改查操作哪个ht"><a href="#3-3-渐进式hash时，增删改查操作哪个ht" class="headerlink" title="(3.3) 渐进式hash时，增删改查操作哪个ht?"></a>(3.3) 渐进式hash时，增删改查操作哪个ht?</h2><p>  当部分bucket 执行 rehash，部分bucket还没有执行rehash，这时增删查请求操作是对ht[1]操作，还是ht[0] ?</p>
<p>  在新增操作时，调用<code>dictAdd</code>，会调用<code>dictAddRaw</code>，有一行代码专门对rehash做了处理，会保存到<code>ht[1]</code>，<code>ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</code></p>
<p>  在更新操作时，调用<code>dictReplace</code>，也会调用<code>dictAddRaw</code>，原理同上</p>
<p>  在删除操作时，调用<code>dictDelete</code>方法，会对<code>ht[0]</code>和<code>ht[1]</code>都做删除， <code>for (table = 0; table &lt;= 1; table++)</code> 这行代码就是要对2个哈希表分表处理</p>
<p>  查询操作，调用<code>dictFind</code>方法，也是会对两个ht都查询，<code>for (table = 0; table &lt;= 1; table++)</code>，先查<code>ht[0]</code>，查到了返回，没有查到再查<code>ht[1]</code></p>
<h2 id="3-4-rehash扩容后有多大-rehash的结果"><a href="#3-4-rehash扩容后有多大-rehash的结果" class="headerlink" title="(3.4) rehash扩容后有多大-rehash的结果"></a>(3.4) rehash扩容后有多大-rehash的结果</h2><p>  在 Redis 中，rehash 对 哈希表空间的扩容是通过调用 dictExpand 函数来完成的。</p>
<p>  dictExpand 函数的参数有两个，一个是要扩容的 哈希表，另一个是要扩到的容量</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;**
 * 扩展或创建哈希表
 * 
 * @param *d 要扩容的哈希表
 * @param size 扩容后的容量
 *&#x2F;
int dictExpand(dict *d, unsigned long size)
&#123;
    &#x2F;&#x2F; 校验
    &#x2F;&#x2F; 如果已经在扩容 或者 扩容后的大小&lt;哈希表中已有的元素数 返回错误
    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size)
        return DICT_ERR;

    dictht n; &#x2F;&#x2F; 新哈希表
    unsigned long realsize &#x3D; _dictNextPower(size); &#x2F;&#x2F; 获取扩容后的大小 (realsize &gt;&#x3D; size 并且 realsize是2的幂次方)

    &#x2F;&#x2F; 扩容后的大小 &#x3D; 当前大小，返回错误
    if (realsize &#x3D;&#x3D; d-&gt;ht[0].size) return DICT_ERR;

    &#x2F;&#x2F; 为新的哈希表分配内存 并 将所有指针初始化为NULL
    n.size &#x3D; realsize; &#x2F;&#x2F; 大小
    n.sizemask &#x3D; realsize-1; &#x2F;&#x2F;  
    n.table &#x3D; zcalloc(realsize*sizeof(dictEntry*));  &#x2F;&#x2F; 分配内存
    n.used &#x3D; 0;  &#x2F;&#x2F; 未使用

    &#x2F;&#x2F; 这是第一次初始化吗？ 如果是这样，那不是真正的重新哈希，我们只是设置第一个哈希表，以便它可以接受keys。  
    if (d-&gt;ht[0].table &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F; 未初始化
        d-&gt;ht[0] &#x3D; n;
        return DICT_OK;
    &#125;

    &#x2F;&#x2F; 为 增量哈希 准备第二个哈希表 &#x2F;&#x2F; Prepare a second hash table for incremental rehashing
    d-&gt;ht[1] &#x3D; n; &#x2F;&#x2F; 设置哈希表
    d-&gt;rehashidx &#x3D; 0; &#x2F;&#x2F; 设置 rehash index
    return DICT_OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 哈希表的容量是2的幂次方 *&#x2F;
static unsigned long _dictNextPower(unsigned long size)
&#123;
    unsigned long i &#x3D; DICT_HT_INITIAL_SIZE; &#x2F;&#x2F; 哈希表初始大小默认是4 

    &#x2F;&#x2F; 如果要扩容的大小已经超过最大值，则返回最大值加1
    if (size &gt;&#x3D; LONG_MAX) return LONG_MAX + 1LU;

    &#x2F;&#x2F; 这里是计算2的幂次方 获取一个&gt;&#x3D;size 的最小2的幂次方
    while(1) &#123;
        &#x2F;&#x2F; 如果扩容大小大于等于要扩容的值，就返回当前值
        if (i &gt;&#x3D; size)
            return i;
        i *&#x3D; 2;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  为什么哈希表的容量要是2的幂次方？<br>  因为容量是2的幂次方，进行计算可以转换为位运算，位运算计算比较快。</p>
<br>

<h1 id="4-Redis里的Hash函数"><a href="#4-Redis里的Hash函数" class="headerlink" title="(4) Redis里的Hash函数"></a>(4) Redis里的Hash函数</h1><p>  Hash 函数会影响 哈希表的查询效率及哈希冲突情况，那么，你能从 Redis 的源码中，找到 哈希表使用的是哪一种 Hash 函数吗？</p>
<p>  在rehash时，<code>dictRehash</code>函数里 从老的<code>ht[0]</code>把数据迁移到<code>ht[1]</code>的时候，需要计算key的hash，与sizemask计算获取数组下标，对应代码是 <code>h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</code></p>
<p>  <code>dictHashKey(d, de-&gt;key)</code> 调用了哈希函数，点进这个方法</p>
<p>  调用 <code>#define dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</code>，也就是使用的 <code>hashFunction(key)</code> 这个函数</p>
<p>  想了想，Hash有多种实现，而且<code>struct dict</code>也定义了<code>dictType *type</code> </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct dictType &#123;
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(void *privdata, const void *key);
    void *(*valDup)(void *privdata, const void *obj);
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    void (*keyDestructor)(void *privdata, void *key);
    void (*valDestructor)(void *privdata, void *obj);
&#125; dictType;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  看到这儿时，找了一下引用<code>dictType</code>的地方，发现有很多，排除掉<code>redis-cli.c</code> <code>sentinel.c</code> 感觉 <code>dict.c</code> 和 <code>server.c</code>里的概率更大<br>  看了一下<code>server.c</code>里的引用，有<code>setDictType</code> <code>zsetDictType</code> <code>dbDictType</code> 而且注释里写着 <code>/* hash function */</code><br>  看了<code>dictSdsHash</code>，对应 <code>dictGenHashFunction</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">uint64_t dictGenHashFunction(const void *key, int len) &#123;
    return siphash(key,len,dict_hash_function_seed);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>  发现使用的<code>siphash.c</code>文件里的<code>siphash</code></p>
<p>  这个方法不太容易看懂</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k) &#123;
#ifndef UNALIGNED_LE_CPU
    uint64_t hash;
    uint8_t *out &#x3D; (uint8_t*) &amp;hash;
#endif
    uint64_t v0 &#x3D; 0x736f6d6570736575ULL;
    uint64_t v1 &#x3D; 0x646f72616e646f6dULL;
    uint64_t v2 &#x3D; 0x6c7967656e657261ULL;
    uint64_t v3 &#x3D; 0x7465646279746573ULL;
    uint64_t k0 &#x3D; U8TO64_LE(k);
    uint64_t k1 &#x3D; U8TO64_LE(k + 8);
    uint64_t m;
    const uint8_t *end &#x3D; in + inlen - (inlen % sizeof(uint64_t));
    const int left &#x3D; inlen &amp; 7;
    uint64_t b &#x3D; ((uint64_t)inlen) &lt;&lt; 56;
    v3 ^&#x3D; k1;
    v2 ^&#x3D; k0;
    v1 ^&#x3D; k1;
    v0 ^&#x3D; k0;

    for (; in !&#x3D; end; in +&#x3D; 8) &#123;
        m &#x3D; U8TO64_LE(in);
        v3 ^&#x3D; m;

        SIPROUND;

        v0 ^&#x3D; m;
    &#125;

    switch (left) &#123;
    case 7: b |&#x3D; ((uint64_t)in[6]) &lt;&lt; 48; &#x2F;* fall-thru *&#x2F;
    case 6: b |&#x3D; ((uint64_t)in[5]) &lt;&lt; 40; &#x2F;* fall-thru *&#x2F;
    case 5: b |&#x3D; ((uint64_t)in[4]) &lt;&lt; 32; &#x2F;* fall-thru *&#x2F;
    case 4: b |&#x3D; ((uint64_t)in[3]) &lt;&lt; 24; &#x2F;* fall-thru *&#x2F;
    case 3: b |&#x3D; ((uint64_t)in[2]) &lt;&lt; 16; &#x2F;* fall-thru *&#x2F;
    case 2: b |&#x3D; ((uint64_t)in[1]) &lt;&lt; 8; &#x2F;* fall-thru *&#x2F;
    case 1: b |&#x3D; ((uint64_t)in[0]); break;
    case 0: break;
    &#125;

    v3 ^&#x3D; b;

    SIPROUND;

    v0 ^&#x3D; b;
    v2 ^&#x3D; 0xff;

    SIPROUND;
    SIPROUND;

    b &#x3D; v0 ^ v1 ^ v2 ^ v3;
#ifndef UNALIGNED_LE_CPU
    U64TO8_LE(out, b);
    return hash;
#else
    return b;
#endif
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、Redis 中的 dict 数据结构，采用「链式哈希」的方式存储，当哈希冲突严重时，会开辟一个新的哈希表，翻倍扩容，并采用「渐进式 rehash」的方式迁移数据</p>
<p>2、所谓「渐进式 rehash」是指，把很大块迁移数据的开销，平摊到多次小的操作中，目的是降低主线程的性能影响</p>
<p>3、Redis 中凡是需要 O(1) 时间获取 k-v 数据的场景，都使用了 dict 这个数据结构，也就是说 dict 是 Redis 中重中之重的「底层数据结构」</p>
<p>4、dict 封装好了友好的「增删改查」API，并在适当时机「自动扩容、缩容」，这给上层数据类型（Hash/Set/Sorted Set）、全局哈希表的实现提供了非常大的便利</p>
<p>5、例如，Redis 中每个 DB 存放数据的「全局哈希表、过期key」都用到了 dict：</p>
<p>6、「全局哈希表」在触发渐进式 rehash 的情况有 2 个：</p>
<ul>
<li>增删改查哈希表时：每次迁移 1 个哈希桶（文章提到的 dict.c 中的 _dictRehashStep 函数）</li>
<li>定时 rehash：如果 dict 一直没有操作，无法渐进式迁移数据，那主线程会默认每间隔 100ms 执行一次迁移操作。这里一次会以 100 个桶为基本单位迁移数据，并限制如果一次操作耗时超时 1ms 就结束本次任务，待下次再次触发迁移（文章没提到这个，详见 dict.c 的 dictRehashMilliseconds 函数）</li>
</ul>
<p>（注意：定时 rehash 只会迁移全局哈希表中的数据，不会定时迁移 Hash/Set/Sorted Set 下的哈希表的数据，这些哈希表只会在操作数据时做实时的渐进式 rehash）</p>
<p>7、dict 在负载因子超过 1 时（used: bucket size &gt;= 1），会触发 rehash。但如果 Redis 正在 RDB 或 AOF rewrite，为避免父进程大量写时复制，会暂时关闭触发 rehash。但这里有个例外，如果负载因子超过了 5（哈希冲突已非常严重），依旧会强制做 rehash（重点）</p>
<p>8、dict 在 rehash 期间，查询旧哈希表找不到结果，还需要在新哈希表查询一次</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/400379">Redis源码剖析与实战 - 03 如何实现一个性能优异的Hash表？</a><br>[2] <a target="_blank" rel="noopener" href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/dict.html">Redis设计与实现 - 字典</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="WKQ 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="WKQ 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/database/" rel="tag"># database</a>
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/01/01/redis-data-structure-simple-dynamic-string/" rel="prev" title="Redis 简单动态字符串 设计">
                  <i class="fa fa-chevron-left"></i> Redis 简单动态字符串 设计
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/01/08/redis-datatype-object/" rel="next" title="Redis对象处理机制">
                  Redis对象处理机制 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WKQ</span>
</div>
<div class="busuanzi-count">
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
