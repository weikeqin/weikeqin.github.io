<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="CBB4A6675274A9B82BB82B104F7915A7">
  <meta name="yandex-verification" content="4fa4531dcc9e1bfd">
  <meta name="baidu-site-verification" content="1d263b839540cec80d3497b2f877c5da">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"weikeqin.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"waline","storage":true,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="(1) 缓存淘汰是什么(2) 为什么要缓存淘汰(3) 缓存淘汰算法&#x2F;页面置换算法原理(3.1) LRU  LRU 算法背后的想法非常朴素：它认为刚刚被访问的数据，肯定还会被再次访问。  选择最近最久未被使用的数据进行淘汰。 优点： 不足：  可能造成缓存污染。 缓存污染：在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 缓存淘汰策略">
<meta property="og:url" content="http://weikeqin.com/2022/03/06/redis-cache-eviction-strategy/index.html">
<meta property="og:site_name" content="天道酬勤">
<meta property="og:description" content="(1) 缓存淘汰是什么(2) 为什么要缓存淘汰(3) 缓存淘汰算法&#x2F;页面置换算法原理(3.1) LRU  LRU 算法背后的想法非常朴素：它认为刚刚被访问的数据，肯定还会被再次访问。  选择最近最久未被使用的数据进行淘汰。 优点： 不足：  可能造成缓存污染。 缓存污染：在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://weikeqin.com/img/database/redis/cache-eviction/lfu/redis-lfu-log-1.png">
<meta property="article:published_time" content="2022-03-06T11:32:45.000Z">
<meta property="article:modified_time" content="2023-04-16T10:14:42.679Z">
<meta property="article:author" content="WKQ">
<meta property="article:tag" content="tech,Redis,MySQL,ElasticSearch,Neo4j,Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://weikeqin.com/img/database/redis/cache-eviction/lfu/redis-lfu-log-1.png">


<link rel="canonical" href="http://weikeqin.com/2022/03/06/redis-cache-eviction-strategy/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://weikeqin.com/2022/03/06/redis-cache-eviction-strategy/","path":"2022/03/06/redis-cache-eviction-strategy/","title":"Redis 缓存淘汰策略"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis 缓存淘汰策略 | 天道酬勤</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?d1ad0ae2a9976c44d556abc07cda1365"></script>






<link rel="dns-prefetch" href="https://fantastic-paletas-170a7a.netlify.app/.netlify/functions/comment">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">天道酬勤</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">坚持，努力，让好事发生</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">(1) 缓存淘汰是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="nav-number">2.</span> <span class="nav-text">(2) 为什么要缓存淘汰</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">(3) 缓存淘汰算法&#x2F;页面置换算法原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-LRU"><span class="nav-number">3.1.</span> <span class="nav-text">(3.1) LRU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-LFU"><span class="nav-number">3.2.</span> <span class="nav-text">(3.2) LFU</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Redis%E9%87%8C%E7%BC%93%E5%AD%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">4.</span> <span class="nav-text">(4) Redis里缓存有哪些淘汰策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">(4.1) Redis内存淘汰机制如何启用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Redis%E9%87%8C%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">(5) Redis里缓存淘汰算法原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Redis-LRU"><span class="nav-number">5.1.</span> <span class="nav-text">(5.1) Redis-LRU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Redis-LFU"><span class="nav-number">5.2.</span> <span class="nav-text">(3.2) Redis-LFU</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-LRU%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-number">6.</span> <span class="nav-text">(4) LRU源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%85%A8%E5%B1%80LRU%E6%97%B6%E9%92%9F%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">6.1.</span> <span class="nav-text">(4.1) 全局LRU时钟值的计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%9C%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%ADLRU%E6%97%B6%E9%92%9F%E5%80%BC%E6%98%AF%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E7%9A%84"><span class="nav-number">6.2.</span> <span class="nav-text">(4.2) 在运行过程中LRU时钟值是如何更新的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-key-value-LRU%E6%97%B6%E9%92%9F%E5%80%BC%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="nav-number">6.3.</span> <span class="nav-text">(4.3) key-value-LRU时钟值的初始化与更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-key-LRU%E6%97%B6%E9%92%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.3.1.</span> <span class="nav-text">(4.3.1) key-LRU时钟初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-key-LRU%E6%97%B6%E9%92%9F%E6%9B%B4%E6%96%B0"><span class="nav-number">6.3.2.</span> <span class="nav-text">(4.3.2) key-LRU时钟更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E8%BF%91%E4%BC%BCLRU%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%99%85%E6%89%A7%E8%A1%8C"><span class="nav-number">6.4.</span> <span class="nav-text">(4.4) 近似LRU算法的实际执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-number">6.4.1.</span> <span class="nav-text">(4.4.1) 触发时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-%E8%BF%91%E4%BC%BCLRU%E7%AE%97%E6%B3%95%E6%89%A7%E8%A1%8C"><span class="nav-number">6.4.2.</span> <span class="nav-text">(4.4.2) 近似LRU算法执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-1-%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5-getMaxmemoryState"><span class="nav-number">6.4.2.1.</span> <span class="nav-text">(4.4.2.1) 判断当前内存使用情况-getMaxmemoryState</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-2-%E6%9B%B4%E6%96%B0%E5%BE%85%E6%B7%98%E6%B1%B0%E7%9A%84%E5%80%99%E9%80%89%E9%94%AE%E5%80%BC%E5%AF%B9%E9%9B%86%E5%90%88-evictionPoolPopulate"><span class="nav-number">6.4.3.</span> <span class="nav-text">(4.4.2.2) 更新待淘汰的候选键值对集合-evictionPoolPopulate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-3-%E9%80%89%E6%8B%A9%E8%A2%AB%E6%B7%98%E6%B1%B0%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E5%B9%B6%E5%88%A0%E9%99%A4-freeMemoryIfNeeded"><span class="nav-number">6.4.4.</span> <span class="nav-text">(4.4.2.3) 选择被淘汰的键值对并删除-freeMemoryIfNeeded</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-LFU%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-number">7.</span> <span class="nav-text">(5) LFU源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E9%94%AE%E5%80%BC%E5%AF%B9%E8%AE%BF%E9%97%AE%E9%A2%91%E7%8E%87%E8%AE%B0%E5%BD%95"><span class="nav-number">7.1.</span> <span class="nav-text">(5.1) 键值对访问频率记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E9%94%AE%E5%80%BC%E5%AF%B9%E8%AE%BF%E9%97%AE%E9%A2%91%E7%8E%87%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%9B%B4%E6%96%B0"><span class="nav-number">7.2.</span> <span class="nav-text">(5.2) 键值对访问频率初始化和更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">7.2.1.</span> <span class="nav-text">(5.2.1) 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E6%9B%B4%E6%96%B0LFU%E5%80%BC"><span class="nav-number">7.2.2.</span> <span class="nav-text">(5.2.2) 更新LFU值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-1-%E9%80%92%E5%87%8F%E8%AE%A1%E6%95%B0%E5%99%A8-LFUDecrAndReturn"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">(5.2.2.1) 递减计数器-LFUDecrAndReturn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-2-%E6%9B%B4%E6%96%B0LFU%E8%AE%A1%E6%95%B0%E5%99%A8-LFULogIncr"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">(5.2.2.2) 更新LFU计数器-LFULogIncr</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-LFU%E7%AE%97%E6%B3%95%E6%B7%98%E6%B1%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">7.3.</span> <span class="nav-text">(5.3) LFU算法淘汰数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5-getMaxmemoryState"><span class="nav-number">7.3.1.</span> <span class="nav-text">(5.3.1) 判断当前内存使用情况-getMaxmemoryState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-%E6%9B%B4%E6%96%B0%E5%BE%85%E6%B7%98%E6%B1%B0%E7%9A%84%E5%80%99%E9%80%89%E9%94%AE%E5%80%BC%E5%AF%B9%E9%9B%86%E5%90%88-evictionPoolPopulate"><span class="nav-number">7.3.2.</span> <span class="nav-text">(5.3.2) 更新待淘汰的候选键值对集合-evictionPoolPopulate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-%E9%80%89%E6%8B%A9%E8%A2%AB%E6%B7%98%E6%B1%B0%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E5%B9%B6%E5%88%A0%E9%99%A4-freeMemoryIfNeeded"><span class="nav-number">7.3.3.</span> <span class="nav-text">(5.3.3) 选择被淘汰的键值对并删除-freeMemoryIfNeeded</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WKQ</p>
  <div class="site-description" itemprop="description">不积跬步无以至千里</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">315</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:weikeqin.cn@gmail.com" title="E-Mail → mailto:weikeqin.cn@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

<div class="revolvermaps">
    <script type="text/javascript" src="//rf.revolvermaps.com/0/0/6.js?i=5rcgvdncuwu&amp;m=7&amp;c=e63100&amp;cr1=ffffff&amp;f=arial&amp;l=0&amp;bv=90&amp;lx=-420&amp;ly=420&amp;hi=20&amp;he=7&amp;hc=a8ddff&amp;rs=80" async="async"></script>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weikeqin.com/2022/03/06/redis-cache-eviction-strategy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WKQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天道酬勤">
      <meta itemprop="description" content="不积跬步无以至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis 缓存淘汰策略 | 天道酬勤">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis 缓存淘汰策略
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-06 19:32:45" itemprop="dateCreated datePublished" datetime="2022-03-06T19:32:45+08:00">2022-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-16 18:14:42" itemprop="dateModified" datetime="2023-04-16T18:14:42+08:00">2023-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2022/03/06/redis-cache-eviction-strategy/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2022/03/06/redis-cache-eviction-strategy/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>39k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>35 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="1-缓存淘汰是什么"><a href="#1-缓存淘汰是什么" class="headerlink" title="(1) 缓存淘汰是什么"></a>(1) 缓存淘汰是什么</h1><h1 id="2-为什么要缓存淘汰"><a href="#2-为什么要缓存淘汰" class="headerlink" title="(2) 为什么要缓存淘汰"></a>(2) 为什么要缓存淘汰</h1><h1 id="3-缓存淘汰算法-页面置换算法原理"><a href="#3-缓存淘汰算法-页面置换算法原理" class="headerlink" title="(3) 缓存淘汰算法/页面置换算法原理"></a>(3) 缓存淘汰算法/页面置换算法原理</h1><h2 id="3-1-LRU"><a href="#3-1-LRU" class="headerlink" title="(3.1) LRU"></a>(3.1) LRU</h2><p>  LRU 算法背后的想法非常朴素：它认为刚刚被访问的数据，肯定还会被再次访问。<br>  选择最近最久未被使用的数据进行淘汰。</p>
<p>优点：</p>
<p>不足：<br>  可能造成缓存污染。</p>
<p><code>缓存污染</code>：在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。</p>
<p>  典型场景：全表扫描，对所有数据进行一次读取，每个数据都被读取到了，</p>
<h2 id="3-2-LFU"><a href="#3-2-LFU" class="headerlink" title="(3.2) LFU"></a>(3.2) LFU</h2><p>  记录数据被访问的频率，选择在最近使用最少的数据进行淘汰。</p>
<p>  LFU算法是根据数据访问的频率来选择被淘汰数据的，所以LFU算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。</p>
<p>  不过，访问次数和访问频率还不能完全等同。访问频率是指在一定时间内的访问次数，也就是说，在计算访问频率时，我们不仅需要记录访问次数，还要记录这些访问是在多长时间内执行的。</p>
<br>


<h1 id="4-Redis里缓存有哪些淘汰策略"><a href="#4-Redis里缓存有哪些淘汰策略" class="headerlink" title="(4) Redis里缓存有哪些淘汰策略"></a>(4) Redis里缓存有哪些淘汰策略</h1><table>
<thead>
<tr>
<th align="left">内存淘汰策略</th>
<th align="left">解释</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">noeviction</td>
<td align="left">不进行数据淘汰</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">allkeys-random</td>
<td align="left">在所有key里随机筛选数据</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">allkeys-lru</td>
<td align="left">在所有key里筛选最近最久未使用的数据</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">allkeys-lfu</td>
<td align="left">在所有key里筛选最近最少使用的数据</td>
<td align="left">Redis 4.0 新增</td>
</tr>
<tr>
<td align="left">volatile-ttl</td>
<td align="left">在有过期时间key里根据过期时间的先后筛选</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile-random</td>
<td align="left">在有过期时间key里随机筛选数据</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile-lru</td>
<td align="left">在有过期时间key里筛选最近最久未使用的数据</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile-lfu</td>
<td align="left">在有过期时间key里筛选最近最少使用的数据</td>
<td align="left">Redis 4.0 新增</td>
</tr>
</tbody></table>
<p>lru (Least Recently Used)   最近最久未使用<br>lfu (Least Frequently Used)  最近最少使用</p>
<p>  在redis3.0之前，默认淘汰策略是<code>volatile-lru</code>；在redis3.0及之后(包括3.0)，默认淘汰策略是<code>noeviction</code>。</p>
<p>  在3.0及之后的版本，Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据。</p>
<p>  对应到 Redis 缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。</p>
<h2 id="4-1-Redis内存淘汰机制如何启用"><a href="#4-1-Redis内存淘汰机制如何启用" class="headerlink" title="(4.1) Redis内存淘汰机制如何启用"></a>(4.1) Redis内存淘汰机制如何启用</h2><p>  Redis 的内存淘汰机制是如何启用近似 LRU 算法的</p>
<p>和Redis配置文件<code>redis.conf</code>中的两个配置参数有关：</p>
<p>  <code>maxmemory</code>，该配置项设定了 Redis server 可以使用的最大内存容量，一旦 server 使用的实际内存量超出该阈值时，server 就会根据 maxmemory-policy 配置项定义的策略，执行内存淘汰操作；</p>
<p>  <code>maxmemory-policy</code>，该配置项设定了 Redis server 的内存淘汰策略，主要包括近似 LRU 算法、LFU 算法、按 TTL 值淘汰和随机淘汰等几种算法。</p>
<br>


<h1 id="5-Redis里缓存淘汰算法原理"><a href="#5-Redis里缓存淘汰算法原理" class="headerlink" title="(5) Redis里缓存淘汰算法原理"></a>(5) Redis里缓存淘汰算法原理</h1><h2 id="5-1-Redis-LRU"><a href="#5-1-Redis-LRU" class="headerlink" title="(5.1) Redis-LRU"></a>(5.1) Redis-LRU</h2><p>  LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。</p>
<p>  而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 性能。</p>
<p>  在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。</p>
<p>  Redis 并没有为所有的数据维护一个全局的链表，而是通过随机采样方式，选取一定数量（例如 100 个）的数据放入候选集合，后续在候选集合中根据 lru 字段值的大小进行筛选。</p>
<!--
  具体来说，Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。
  然后，Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。

Redis 提供了一个配置参数 maxmemory-samples，这个参数就是 Redis 选出的数据个数 N。

 我们执行如下命令，可以让 Redis 选出 100 个数据作为候选数据集：

CONFIG SET maxmemory-samples 100

当需要再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。这儿的挑选标准是：能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值。当有新数据进入候选数据集后，如果候选数据集中的数据个数达到了 maxmemory-samples，Redis 就把候选数据集中 lru 字段值最小的数据淘汰出去。

这样一来，Redis 缓存不用为所有的数据维护一个大链表，也不用在每次数据访问时都移动链表项，提升了缓存的性能。

-->


<h2 id="3-2-Redis-LFU"><a href="#3-2-Redis-LFU" class="headerlink" title="(3.2) Redis-LFU"></a>(3.2) Redis-LFU</h2><p>  LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。</p>
<p>  当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。<br>  如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。</p>
<p>Redis 在实现 LFU 策略的时候，只是把原来 24bit 大小的 lru 字段，又进一步拆分成了两部分。<br>ldt 值：lru 字段的前 16bit，表示数据的访问时间戳；<br>counter 值：lru 字段的后 8bit，表示数据的访问次数。</p>
<p>在实现 LFU 策略时，Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，而是采用了一个更优化的计数规则。</p>
<p>LFU 策略实现的计数规则是：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>RAND_MAX<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">double</span> p <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span><span class="token punctuation">(</span>baseval<span class="token operator">*</span>server<span class="token punctuation">.</span>lfu_log_factor<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> p<span class="token punctuation">)</span> counter<span class="token operator">++</span><span class="token punctuation">;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<br>


<h1 id="4-LRU源码解读"><a href="#4-LRU源码解读" class="headerlink" title="(4) LRU源码解读"></a>(4) LRU源码解读</h1><h2 id="4-1-全局LRU时钟值的计算"><a href="#4-1-全局LRU时钟值的计算" class="headerlink" title="(4.1) 全局LRU时钟值的计算"></a>(4.1) 全局LRU时钟值的计算</h2><p>   LRU算法需要知道数据的最近一次访问时间。因此，Redis设计了LRU时钟来记录数据每次访问的时间戳。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/server.h </span>

<span class="token comment">/*
 * redis对象
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment">// 数据类型 （string/list/hash/set/zset等）</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment">// 编码方式 </span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span>  <span class="token comment">// LRU时间(相对于全局 lru_clock) </span>
                            <span class="token comment">// 或 LFU数据(低8位保存频率 和 高16位保存访问时间)。  </span>
                            <span class="token comment">// LRU_BITS为24个bits</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>  <span class="token comment">// 引用计数  4字节</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>  <span class="token comment">// 指针 指向对象的值  8字节</span>
<span class="token punctuation">&#125;</span> robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/server.c</span>

<span class="token keyword">void</span> <span class="token function">initServerConfig</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">// 计算全局LRU时钟值</span>
    server<span class="token punctuation">.</span>lruclock <span class="token operator">=</span> <span class="token function">getLRUClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/evict.c</span>

<span class="token comment">/* 
 * 根据时钟分辨率返回 LRU 时钟。 
 * 这是一个减少位格式的时间，可用于设置和检查 redisObject 结构的 object->lru 字段。
 */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">getLRUClock</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// mstime()是毫秒时间戳  // mstime()/1000=秒级时间戳</span>
    <span class="token comment">// 与运算 保证值 &lt;= LRU_CLOCK_MAX</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>LRU_CLOCK_RESOLUTION<span class="token punctuation">)</span> <span class="token operator">&amp;</span> LRU_CLOCK_MAX<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  从代码可以看出，LRU时钟精度是1000毫秒，也就是1秒。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LRU_BITS</span> <span class="token expression"><span class="token number">24</span></span></span>

<span class="token comment">// obj->lru的最大值 // LRU_CLOCK_MAX = 1^24 - 1</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LRU_CLOCK_MAX</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>LRU_BITS<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> </span><span class="token comment">/* Max value of obj->lru */</span></span>

<span class="token comment">// LRU 时钟分辨率(毫秒)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LRU_CLOCK_RESOLUTION</span> <span class="token expression"><span class="token number">1000</span> </span><span class="token comment">/* LRU clock resolution in ms */</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/server.c</span>

<span class="token comment">/* 
 * 返回UNIX毫秒时间戳
 * Return the UNIX time in milliseconds 
 */</span>
<span class="token class-name">mstime_t</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/server.c</span>

<span class="token comment">/*
 * 返回UNIX微秒时间戳 
 * Return the UNIX time in microseconds 
 */</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> ust<span class="token punctuation">;</span>

    <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tv<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ust <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>tv<span class="token punctuation">.</span>tv_sec<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000000</span><span class="token punctuation">;</span>
    ust <span class="token operator">+=</span> tv<span class="token punctuation">.</span>tv_usec<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ust<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="4-2-在运行过程中LRU时钟值是如何更新的"><a href="#4-2-在运行过程中LRU时钟值是如何更新的" class="headerlink" title="(4.2) 在运行过程中LRU时钟值是如何更新的"></a>(4.2) 在运行过程中LRU时钟值是如何更新的</h2><p>  和 Redis server 在事件驱动框架中，定期运行的时间事件所对应的 serverCron 函数有关。</p>
<p>  serverCron 函数作为时间事件的回调函数，本身会按照一定的频率周期性执行，其频率值是由 Redis 配置文件 redis.conf 中的 hz 配置项决定的。</p>
<p>  hz 配置项的默认值是 10，这表示 serverCron 函数会每 100 毫秒(1秒 / 10 = 100 毫秒)运行一次。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/server.c</span>

<span class="token comment">/* This is our timer interrupt, called server.hz times per second.
 * Here is where we do a number of things that need to be done asynchronously.
 * For instance:
 *
 * - Active expired keys collection (it is also performed in a lazy way on
 *   lookup).
 * - Software watchdog.
 * - Update some statistic.
 * - Incremental rehashing of the DBs hash tables.
 * - Triggering BGSAVE / AOF rewrite, and handling of terminated children.
 * - Clients timeout of different kinds.
 * - Replication reconnection.
 * - Many more...
 *
 * Everything directly called here will be called server.hz times per second,
 * so in order to throttle execution of things we want to do less frequently
 * a macro is used: run_with_period(milliseconds) &#123; .... &#125;
 */</span>

<span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">/* We have just LRU_BITS bits per object for LRU information.
     * So we use an (eventually wrapping) LRU clock.
     *
     * Note that even if the counter wraps it's not a big problem,
     * everything will still work but some object will appear younger
     * to Redis. However for this to happen a given object should never be
     * touched for all the time needed to the counter to wrap, which is
     * not likely.
     *
     * Note that you can change the resolution altering the
     * LRU_CLOCK_RESOLUTION define. */</span>
    <span class="token comment">// 默认情况下，每100毫秒调用getLRUClock函数更新一次全局LRU时钟值 </span>
    server<span class="token punctuation">.</span>lruclock <span class="token operator">=</span> <span class="token function">getLRUClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  这样一来，每个键值对就可以从全局 LRU 时钟获取最新的访问时间戳了。</p>
<h2 id="4-3-key-value-LRU时钟值的初始化与更新"><a href="#4-3-key-value-LRU时钟值的初始化与更新" class="headerlink" title="(4.3) key-value-LRU时钟值的初始化与更新"></a>(4.3) key-value-LRU时钟值的初始化与更新</h2><h3 id="4-3-1-key-LRU时钟初始化"><a href="#4-3-1-key-LRU时钟初始化" class="headerlink" title="(4.3.1) key-LRU时钟初始化"></a>(4.3.1) key-LRU时钟初始化</h3><p>  对于key-value来说，它的 LRU 时钟值最初是在这个键值对被创建的时候，进行初始化设置的，这个初始化操作是在 createObject 函数中调用的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/object.c</span>

<span class="token comment">/*
 * 创建一个redisObject对象
 *
 * @param type redisObject的类型
 * @param *ptr 值的指针
 */</span>
robj <span class="token operator">*</span><span class="token function">createObject</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 为redisObject结构体分配内存空间</span>
    robj <span class="token operator">*</span>o <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 省略部分代码 </span>

    <span class="token comment">// 将lru字段设置为当前的 lruclock（分钟分辨率），或者 LFU 计数器。 </span>
    <span class="token comment">// 判断内存过期策略</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 对应lfu </span>
        <span class="token comment">// LFU_INIT_VAL=5 对应二进制是 0101 </span>
        <span class="token comment">// 或运算 </span>
        o<span class="token operator">-></span>lru <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">LFUGetTimeInMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> LFU_INIT_VAL<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 对应lru </span>
        o<span class="token operator">-></span>lru <span class="token operator">=</span> <span class="token function">LRU_CLOCK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="4-3-2-key-LRU时钟更新"><a href="#4-3-2-key-LRU时钟更新" class="headerlink" title="(4.3.2) key-LRU时钟更新"></a>(4.3.2) key-LRU时钟更新</h3><p>  只要一个key被访问了，它的 LRU 时钟值就会被更新。而当一个键值对被访问时，访问操作最终都会调用 <code>lookupKey</code> 函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/db.c</span>

<span class="token comment">/* 
 * 低级key查找API
 * 实际上并没有直接从应该依赖lookupKeyRead()、lookupKeyWrite()和lookupKeyReadWithFlags()的命令实现中调用。
 */</span>
robj <span class="token operator">*</span><span class="token function">lookupKey</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    dictEntry <span class="token operator">*</span>de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>db<span class="token operator">-></span>dict<span class="token punctuation">,</span>key<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果节点存在</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 从节点里获取redisObject</span>
        robj <span class="token operator">*</span>val <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* 
         * 更新老化算法的访问时间。
         * 如果我们有一个正在保存的子进程，请不要这样做，因为这会触发疯狂写入副本。
         */</span>
        <span class="token comment">// 没有活跃子进程 并且  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasActiveChildProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> LOOKUP_NOTOUCH<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 更新lfu</span>
                <span class="token function">updateLFU</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 更新lru时间</span>
                val<span class="token operator">-></span>lru <span class="token operator">=</span> <span class="token function">LRU_CLOCK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<br>


<h2 id="4-4-近似LRU算法的实际执行"><a href="#4-4-近似LRU算法的实际执行" class="headerlink" title="(4.4) 近似LRU算法的实际执行"></a>(4.4) 近似LRU算法的实际执行</h2><p>  Redis 之所以实现近似 LRU 算法的目的，是为了减少内存资源和操作时间上的开销。<br>  何时触发算法执行？<br>  算法具体如何执行？</p>
<h3 id="4-4-1-触发时机"><a href="#4-4-1-触发时机" class="headerlink" title="(4.4.1) 触发时机"></a>(4.4.1) 触发时机</h3><p>  近似 LRU 算法的主要逻辑是在 freeMemoryIfNeeded 函数中实现的</p>
<p>  processCommand -&gt; freeMemoryIfNeededAndSafe -&gt; freeMemoryIfNeeded</p>
<h3 id="4-4-2-近似LRU算法执行"><a href="#4-4-2-近似LRU算法执行" class="headerlink" title="(4.4.2) 近似LRU算法执行"></a>(4.4.2) 近似LRU算法执行</h3><p>主要分3大步</p>
<ol>
<li>判断当前内存使用情况-getMaxmemoryState</li>
<li>更新待淘汰的候选键值对集合-evictionPoolPopulate</li>
<li>选择被淘汰的键值对并删除-freeMemoryIfNeeded</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/evict.c</span>

<span class="token comment">/* This function is periodically called to see if there is memory to free
 * according to the current "maxmemory" settings. In case we are over the
 * memory limit, the function will try to free some memory to return back
 * under the limit.
 *
 * The function returns C_OK if we are under the memory limit or if we
 * were over the limit, but the attempt to free memory was successful.
 * Otherwise if we are over the memory limit, but not enough memory
 * was freed to return back under the limit, the function returns C_ERR. 
 */</span>
<span class="token keyword">int</span> <span class="token function">freeMemoryIfNeeded</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> keys_freed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/* By default replicas should ignore maxmemory
     * and just be masters exact copies. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>repl_slave_ignore_maxmemory<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token class-name">size_t</span> mem_reported<span class="token punctuation">,</span> mem_tofree<span class="token punctuation">,</span> mem_freed<span class="token punctuation">;</span>
    <span class="token class-name">mstime_t</span> latency<span class="token punctuation">,</span> eviction_latency<span class="token punctuation">,</span> lazyfree_latency<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> delta<span class="token punctuation">;</span>
    <span class="token keyword">int</span> slaves <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>

    <span class="token comment">/* When clients are paused the dataset should be static not just from the
     * POV of clients not being able to write, but also from the POV of
     * expires and evictions of keys not being performed. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientsArePaused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">// 如果当前内存使用量没有超过 maxmemory，返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_reported<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>mem_tofree<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span>
        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">// 已经释放的内存大小</span>
    mem_freed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_NO_EVICTION<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> cant_free<span class="token punctuation">;</span> <span class="token comment">/* We need to free memory, but policy forbids. */</span>

    <span class="token comment">// 已经释放的内存大小 &lt; 计划要释放的内存大小</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>mem_freed <span class="token operator">&lt;</span> mem_tofree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> next_db <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        sds bestkey <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> bestdbid<span class="token punctuation">;</span>
        redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>
        dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
        dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> <span class="token punctuation">(</span>MAXMEMORY_FLAG_LRU<span class="token operator">|</span>MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token operator">||</span>
            server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_VOLATILE_TTL<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">// 淘汰池 / 采样key集合</span>
            <span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token operator">*</span>pool <span class="token operator">=</span> EvictionPoolLRU<span class="token punctuation">;</span>

            <span class="token keyword">while</span><span class="token punctuation">(</span>bestkey <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_keys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> keys<span class="token punctuation">;</span>

                <span class="token comment">// 在keys过期时我们不想创建本地数据库去选择(哪些key删除)，</span>
                <span class="token comment">// 因此开始在每个数据库中填充采样key的淘汰池。 </span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>i<span class="token punctuation">;</span>
                    dict <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_ALLKEYS<span class="token punctuation">)</span> <span class="token operator">?</span>
                            db<span class="token operator">-></span>dict <span class="token operator">:</span> db<span class="token operator">-></span>expires<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>keys <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token function">evictionPoolPopulate</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> dict<span class="token punctuation">,</span> db<span class="token operator">-></span>dict<span class="token punctuation">,</span> pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        total_keys <span class="token operator">+=</span> keys<span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>total_keys<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">/* No keys to evict. */</span>

                <span class="token comment">/* Go backward from best to worst element to evict. */</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    bestdbid <span class="token operator">=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">;</span>

                    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_ALLKEYS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">]</span><span class="token punctuation">.</span>dict<span class="token punctuation">,</span>
                            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">]</span><span class="token punctuation">.</span>expires<span class="token punctuation">,</span>
                            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>

                    <span class="token comment">/* Remove the entry from the pool. */</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">)</span>
                        <span class="token function">sdsfree</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                    pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>idle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

                    <span class="token comment">/* If the key exists, is our pick. Otherwise it is
                     * a ghost and we need to try the next element. */</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        bestkey <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                        <span class="token comment">/* Ghost... Iterate again. */</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* volatile-random and allkeys-random policy */</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_ALLKEYS_RANDOM <span class="token operator">||</span>
                 server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_VOLATILE_RANDOM<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">/* When evicting a random key, we try to evict a key for
             * each DB, so we use the static 'next_db' variable to
             * incrementally visit all DBs. */</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span>next_db<span class="token punctuation">)</span> <span class="token operator">%</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span>
                db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>j<span class="token punctuation">;</span>
                dict <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_ALLKEYS_RANDOM<span class="token punctuation">)</span> <span class="token operator">?</span>
                        db<span class="token operator">-></span>dict <span class="token operator">:</span> db<span class="token operator">-></span>expires<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    de <span class="token operator">=</span> <span class="token function">dictGetRandomKey</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    bestkey <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    bestdbid <span class="token operator">=</span> j<span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Finally remove the selected key. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bestkey<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>bestdbid<span class="token punctuation">;</span>
            robj <span class="token operator">*</span>keyobj <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span>bestkey<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>bestkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">propagateExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">,</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">/* We compute the amount of memory freed by db*Delete() alone.
             * It is possible that actually the memory needed to propagate
             * the DEL in AOF and replication link is greater than the one
             * we are freeing removing the key, but we can't account for
             * that otherwise we would never exit the loop.
             *
             * Same for CSC invalidation messages generated by signalModifiedKey.
             *
             * AOF and Output buffer memory will be freed eventually so
             * we only care about memory used by the key space. */</span>
            delta <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>eviction_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction<span class="token punctuation">)</span>
                <span class="token function">dbAsyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">dbSyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>eviction_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"eviction-del"</span><span class="token punctuation">,</span>eviction_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
            delta <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            mem_freed <span class="token operator">+=</span> delta<span class="token punctuation">;</span>
            server<span class="token punctuation">.</span>stat_evictedkeys<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token function">signalModifiedKey</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span>NOTIFY_EVICTED<span class="token punctuation">,</span> <span class="token string">"evicted"</span><span class="token punctuation">,</span>
                keyobj<span class="token punctuation">,</span> db<span class="token operator">-></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">decrRefCount</span><span class="token punctuation">(</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            keys_freed<span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token comment">/* When the memory to free starts to be big enough, we may
             * start spending so much time here that is impossible to
             * deliver data to the slaves fast enough, so we force the
             * transmission here inside the loop. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>slaves<span class="token punctuation">)</span> <span class="token function">flushSlavesOutputBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">/* Normally our stop condition is the ability to release
             * a fixed, pre-computed amount of memory. However when we
             * are deleting objects in another thread, it's better to
             * check, from time to time, if we already reached our target
             * memory, since the "mem_freed" amount is computed only
             * across the dbAsyncDelete() call, while the thread can
             * release the memory all the time. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>keys_freed <span class="token operator">%</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token comment">/* Let's satisfy our stop condition. */</span>
                    mem_freed <span class="token operator">=</span> mem_tofree<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">goto</span> cant_free<span class="token punctuation">;</span> <span class="token comment">/* nothing to free... */</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    result <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>

cant_free<span class="token operator">:</span>
    <span class="token comment">/* We are here if we are not able to reclaim memory. There is only one
     * last thing we can try: check if the lazyfree thread has jobs in queue
     * and wait... */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>lazyfree_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">bioPendingJobsOfType</span><span class="token punctuation">(</span>BIO_LAZY_FREE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>lazyfree_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"eviction-lazyfree"</span><span class="token punctuation">,</span>lazyfree_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"eviction-cycle"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h4 id="4-4-2-1-判断当前内存使用情况-getMaxmemoryState"><a href="#4-4-2-1-判断当前内存使用情况-getMaxmemoryState" class="headerlink" title="(4.4.2.1) 判断当前内存使用情况-getMaxmemoryState"></a>(4.4.2.1) 判断当前内存使用情况-getMaxmemoryState</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/evict.c</span>

<span class="token comment">/* Get the memory status from the point of view of the maxmemory directive:
 * if the memory used is under the maxmemory setting then C_OK is returned.
 * Otherwise, if we are over the memory limit, the function returns
 * C_ERR.
 *
 * The function may return additional info via reference, only if the
 * pointers to the respective arguments is not NULL. Certain fields are
 * populated only when C_ERR is returned:
 *
 *  'total'     total amount of bytes used.
 *              (Populated both for C_ERR and C_OK)
 *
 *  'logical'   the amount of memory used minus the slaves/AOF buffers.
 *              (Populated when C_ERR is returned)
 *
 *  'tofree'    the amount of memory that should be released
 *              in order to return back into the memory limits.
 *              (Populated when C_ERR is returned)
 *
 *  'level'     this usually ranges from 0 to 1, and reports the amount of
 *              memory currently used. May be > 1 if we are over the memory
 *              limit.
 *              (Populated both for C_ERR and C_OK)
 */</span>
<span class="token keyword">int</span> <span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span>total<span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span>logical<span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span>tofree<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">size_t</span> mem_reported<span class="token punctuation">,</span> mem_used<span class="token punctuation">,</span> mem_tofree<span class="token punctuation">;</span>

    <span class="token comment">/* Check if we are over the memory usage limit. If we are not, no need
     * to subtract the slaves output buffers. We can just return ASAP. */</span>
    mem_reported <span class="token operator">=</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>total<span class="token punctuation">)</span> <span class="token operator">*</span>total <span class="token operator">=</span> mem_reported<span class="token punctuation">;</span>

    <span class="token comment">/* We may return ASAP if there is no need to compute the level. */</span>
    <span class="token keyword">int</span> return_ok_asap <span class="token operator">=</span> <span class="token operator">!</span>server<span class="token punctuation">.</span>maxmemory <span class="token operator">||</span> mem_reported <span class="token operator">&lt;=</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>return_ok_asap <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>level<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">/* Remove the size of slaves output buffers and AOF buffer from the
     * count of used memory. */</span>
    mem_used <span class="token operator">=</span> mem_reported<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> overhead <span class="token operator">=</span> <span class="token function">freeMemoryGetNotCountedMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mem_used <span class="token operator">=</span> <span class="token punctuation">(</span>mem_used <span class="token operator">></span> overhead<span class="token punctuation">)</span> <span class="token operator">?</span> mem_used<span class="token operator">-</span>overhead <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">/* Compute the ratio of memory usage. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">*</span>level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">*</span>level <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>mem_used <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>return_ok_asap<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">/* Check if we are still over the memory limit. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mem_used <span class="token operator">&lt;=</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">/* Compute how much memory we need to free. */</span>
    mem_tofree <span class="token operator">=</span> mem_used <span class="token operator">-</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>logical<span class="token punctuation">)</span> <span class="token operator">*</span>logical <span class="token operator">=</span> mem_used<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tofree<span class="token punctuation">)</span> <span class="token operator">*</span>tofree <span class="token operator">=</span> mem_tofree<span class="token punctuation">;</span>

    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="4-4-2-2-更新待淘汰的候选键值对集合-evictionPoolPopulate"><a href="#4-4-2-2-更新待淘汰的候选键值对集合-evictionPoolPopulate" class="headerlink" title="(4.4.2.2) 更新待淘汰的候选键值对集合-evictionPoolPopulate"></a>(4.4.2.2) 更新待淘汰的候选键值对集合-evictionPoolPopulate</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/evict.c</span>

<span class="token comment">/* This is an helper function for freeMemoryIfNeeded(), it is used in order
 * to populate the evictionPool with a few entries every time we want to
 * expire a key. Keys with idle time smaller than one of the current
 * keys are added. Keys are always added if there are free entries.
 *
 * We insert keys on place in ascending order, so keys with the smaller
 * idle time are on the left, and keys with the higher idle time on the
 * right. */</span>

<span class="token keyword">void</span> <span class="token function">evictionPoolPopulate</span><span class="token punctuation">(</span><span class="token keyword">int</span> dbid<span class="token punctuation">,</span> dict <span class="token operator">*</span>sampledict<span class="token punctuation">,</span> dict <span class="token operator">*</span>keydict<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token operator">*</span>pool<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> count<span class="token punctuation">;</span>
    dictEntry <span class="token operator">*</span>samples<span class="token punctuation">[</span>server<span class="token punctuation">.</span>maxmemory_samples<span class="token punctuation">]</span><span class="token punctuation">;</span>

    count <span class="token operator">=</span> <span class="token function">dictGetSomeKeys</span><span class="token punctuation">(</span>sampledict<span class="token punctuation">,</span>samples<span class="token punctuation">,</span>server<span class="token punctuation">.</span>maxmemory_samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> idle<span class="token punctuation">;</span>
        sds key<span class="token punctuation">;</span>
        robj <span class="token operator">*</span>o<span class="token punctuation">;</span>
        dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>

        de <span class="token operator">=</span> samples<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        key <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* If the dictionary we are sampling from is not the main
         * dictionary (but the expires one) we need to lookup the key
         * again in the key dictionary to obtain the value object. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">!=</span> MAXMEMORY_VOLATILE_TTL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sampledict <span class="token operator">!=</span> keydict<span class="token punctuation">)</span> de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>keydict<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            o <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Calculate the idle time according to the policy. This is called
         * idle just because the code initially handled LRU, but is in fact
         * just a score where an higher score means better candidate. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LRU<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            idle <span class="token operator">=</span> <span class="token function">estimateObjectIdleTime</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* When we use an LRU policy, we sort the keys by idle time
             * so that we expire keys starting from greater idle time.
             * However when the policy is an LFU one, we have a frequency
             * estimation, and we want to evict keys with lower frequency
             * first. So inside the pool we put objects using the inverted
             * frequency subtracting the actual frequency to the maximum
             * frequency of 255. */</span>
            idle <span class="token operator">=</span> <span class="token number">255</span><span class="token operator">-</span><span class="token function">LFUDecrAndReturn</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_VOLATILE_TTL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* In this case the sooner the expire the better. */</span>
            idle <span class="token operator">=</span> ULLONG_MAX <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown eviction policy in evictionPoolPopulate()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Insert the element inside the pool.
         * First, find the first empty bucket or the first populated
         * bucket that has an idle time smaller than our idle time. */</span>
        k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> EVPOOL_SIZE <span class="token operator">&amp;&amp;</span>
               pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span>
               pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>idle <span class="token operator">&lt;</span> idle<span class="token punctuation">)</span> k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pool<span class="token punctuation">[</span>EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* Can't insert if the element is &lt; the worst element we have
             * and there are no empty buckets. */</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> EVPOOL_SIZE <span class="token operator">&amp;&amp;</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* Inserting into empty position. No setup needed before insert. */</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* Inserting in the middle. Now k points to the first element
             * greater than the element to insert.  */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">/* Free space on the right? Insert at k shifting
                 * all the elements from k to end to the right. */</span>

                <span class="token comment">/* Save SDS before overwriting. */</span>
                sds cached <span class="token operator">=</span> pool<span class="token punctuation">[</span>EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">;</span>
                <span class="token function">memmove</span><span class="token punctuation">(</span>pool<span class="token operator">+</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>pool<span class="token operator">+</span>k<span class="token punctuation">,</span>
                    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>EVPOOL_SIZE<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached <span class="token operator">=</span> cached<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">/* No free space on right? Insert at k-1 */</span>
                k<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token comment">/* Shift all elements on the left of k (included) to the
                 * left, so we discard the element with smaller idle time. */</span>
                sds cached <span class="token operator">=</span> pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">;</span> <span class="token comment">/* Save SDS before overwriting. */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">)</span> <span class="token function">sdsfree</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">memmove</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span>pool<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
                pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached <span class="token operator">=</span> cached<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Try to reuse the cached SDS string allocated in the pool entry,
         * because allocating and deallocating this object is costly
         * (according to the profiler, not my fantasy. Remember:
         * premature optimization bla bla bla. */</span>
        <span class="token keyword">int</span> klen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>klen <span class="token operator">></span> EVPOOL_CACHED_SDS_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token function">sdsdup</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">memcpy</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">,</span>key<span class="token punctuation">,</span>klen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sdssetlen</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">,</span>klen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>idle <span class="token operator">=</span> idle<span class="token punctuation">;</span>
        pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid <span class="token operator">=</span> dbid<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-4-2-3-选择被淘汰的键值对并删除-freeMemoryIfNeeded"><a href="#4-4-2-3-选择被淘汰的键值对并删除-freeMemoryIfNeeded" class="headerlink" title="(4.4.2.3) 选择被淘汰的键值对并删除-freeMemoryIfNeeded"></a>(4.4.2.3) 选择被淘汰的键值对并删除-freeMemoryIfNeeded</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/evict.c</span>

<span class="token comment">/* This function is periodically called to see if there is memory to free
 * according to the current "maxmemory" settings. In case we are over the
 * memory limit, the function will try to free some memory to return back
 * under the limit.
 *
 * The function returns C_OK if we are under the memory limit or if we
 * were over the limit, but the attempt to free memory was successful.
 * Otherwise if we are over the memory limit, but not enough memory
 * was freed to return back under the limit, the function returns C_ERR. */</span>
<span class="token keyword">int</span> <span class="token function">freeMemoryIfNeeded</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> keys_freed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/* By default replicas should ignore maxmemory
     * and just be masters exact copies. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>repl_slave_ignore_maxmemory<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token class-name">size_t</span> mem_reported<span class="token punctuation">,</span> mem_tofree<span class="token punctuation">,</span> mem_freed<span class="token punctuation">;</span>
    <span class="token class-name">mstime_t</span> latency<span class="token punctuation">,</span> eviction_latency<span class="token punctuation">,</span> lazyfree_latency<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> delta<span class="token punctuation">;</span>
    <span class="token keyword">int</span> slaves <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>

    <span class="token comment">/* When clients are paused the dataset should be static not just from the
     * POV of clients not being able to write, but also from the POV of
     * expires and evictions of keys not being performed. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientsArePaused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_reported<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>mem_tofree<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span>
        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    mem_freed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_NO_EVICTION<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> cant_free<span class="token punctuation">;</span> <span class="token comment">/* We need to free memory, but policy forbids. */</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>mem_freed <span class="token operator">&lt;</span> mem_tofree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> next_db <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        sds bestkey <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> bestdbid<span class="token punctuation">;</span>
        redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>
        dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
        dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> <span class="token punctuation">(</span>MAXMEMORY_FLAG_LRU<span class="token operator">|</span>MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token operator">||</span>
            server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_VOLATILE_TTL<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token operator">*</span>pool <span class="token operator">=</span> EvictionPoolLRU<span class="token punctuation">;</span>

            <span class="token keyword">while</span><span class="token punctuation">(</span>bestkey <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_keys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> keys<span class="token punctuation">;</span>

                <span class="token comment">/* We don't want to make local-db choices when expiring keys,
                 * so to start populate the eviction pool sampling keys from
                 * every DB. */</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>i<span class="token punctuation">;</span>
                    dict <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_ALLKEYS<span class="token punctuation">)</span> <span class="token operator">?</span>
                            db<span class="token operator">-></span>dict <span class="token operator">:</span> db<span class="token operator">-></span>expires<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>keys <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token function">evictionPoolPopulate</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> dict<span class="token punctuation">,</span> db<span class="token operator">-></span>dict<span class="token punctuation">,</span> pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        total_keys <span class="token operator">+=</span> keys<span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>total_keys<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">/* No keys to evict. */</span>

                <span class="token comment">/* Go backward from best to worst element to evict. */</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    bestdbid <span class="token operator">=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">;</span>

                    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_ALLKEYS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">]</span><span class="token punctuation">.</span>dict<span class="token punctuation">,</span>
                            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">]</span><span class="token punctuation">.</span>expires<span class="token punctuation">,</span>
                            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>

                    <span class="token comment">/* Remove the entry from the pool. */</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">)</span>
                        <span class="token function">sdsfree</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                    pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>idle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

                    <span class="token comment">/* If the key exists, is our pick. Otherwise it is
                     * a ghost and we need to try the next element. */</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        bestkey <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                        <span class="token comment">/* Ghost... Iterate again. */</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* volatile-random and allkeys-random policy */</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_ALLKEYS_RANDOM <span class="token operator">||</span>
                 server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_VOLATILE_RANDOM<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">/* When evicting a random key, we try to evict a key for
             * each DB, so we use the static 'next_db' variable to
             * incrementally visit all DBs. */</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span>next_db<span class="token punctuation">)</span> <span class="token operator">%</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span>
                db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>j<span class="token punctuation">;</span>
                dict <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_ALLKEYS_RANDOM<span class="token punctuation">)</span> <span class="token operator">?</span>
                        db<span class="token operator">-></span>dict <span class="token operator">:</span> db<span class="token operator">-></span>expires<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    de <span class="token operator">=</span> <span class="token function">dictGetRandomKey</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    bestkey <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    bestdbid <span class="token operator">=</span> j<span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Finally remove the selected key. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bestkey<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>bestdbid<span class="token punctuation">;</span>
            robj <span class="token operator">*</span>keyobj <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span>bestkey<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>bestkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">propagateExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">,</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">/* We compute the amount of memory freed by db*Delete() alone.
             * It is possible that actually the memory needed to propagate
             * the DEL in AOF and replication link is greater than the one
             * we are freeing removing the key, but we can't account for
             * that otherwise we would never exit the loop.
             *
             * Same for CSC invalidation messages generated by signalModifiedKey.
             *
             * AOF and Output buffer memory will be freed eventually so
             * we only care about memory used by the key space. */</span>
            delta <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>eviction_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction<span class="token punctuation">)</span>
                <span class="token function">dbAsyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">dbSyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>eviction_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"eviction-del"</span><span class="token punctuation">,</span>eviction_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
            delta <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            mem_freed <span class="token operator">+=</span> delta<span class="token punctuation">;</span>
            server<span class="token punctuation">.</span>stat_evictedkeys<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token function">signalModifiedKey</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span>NOTIFY_EVICTED<span class="token punctuation">,</span> <span class="token string">"evicted"</span><span class="token punctuation">,</span>
                keyobj<span class="token punctuation">,</span> db<span class="token operator">-></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">decrRefCount</span><span class="token punctuation">(</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            keys_freed<span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token comment">/* When the memory to free starts to be big enough, we may
             * start spending so much time here that is impossible to
             * deliver data to the slaves fast enough, so we force the
             * transmission here inside the loop. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>slaves<span class="token punctuation">)</span> <span class="token function">flushSlavesOutputBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">/* Normally our stop condition is the ability to release
             * a fixed, pre-computed amount of memory. However when we
             * are deleting objects in another thread, it's better to
             * check, from time to time, if we already reached our target
             * memory, since the "mem_freed" amount is computed only
             * across the dbAsyncDelete() call, while the thread can
             * release the memory all the time. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>keys_freed <span class="token operator">%</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token comment">/* Let's satisfy our stop condition. */</span>
                    mem_freed <span class="token operator">=</span> mem_tofree<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">goto</span> cant_free<span class="token punctuation">;</span> <span class="token comment">/* nothing to free... */</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    result <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>

cant_free<span class="token operator">:</span>
    <span class="token comment">/* We are here if we are not able to reclaim memory. There is only one
     * last thing we can try: check if the lazyfree thread has jobs in queue
     * and wait... */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>lazyfree_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">bioPendingJobsOfType</span><span class="token punctuation">(</span>BIO_LAZY_FREE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>lazyfree_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"eviction-lazyfree"</span><span class="token punctuation">,</span>lazyfree_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"eviction-cycle"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>





<h1 id="5-LFU源码解读"><a href="#5-LFU源码解读" class="headerlink" title="(5) LFU源码解读"></a>(5) LFU源码解读</h1><p>  LFU 算法的启用，是通过设置 Redis 配置文件 redis.conf 中的 maxmemory 和 maxmemory-policy。</p>
<p>LFU 算法的实现可以分成三部分内容，分别是键值对访问频率记录、键值对访问频率初始化和更新，以及LFU算法淘汰数据。</p>
<h2 id="5-1-键值对访问频率记录"><a href="#5-1-键值对访问频率记录" class="headerlink" title="(5.1) 键值对访问频率记录"></a>(5.1) 键值对访问频率记录</h2><p>  每个键值对的值都对应了一个 redisObject 结构体，其中有一个 24 bits 的 lru 变量。</p>
<p>  LRU 算法和 LFU 算法并不会同时使用。为了节省内存开销，Redis 源码就复用了 lru 变量来记录 LFU 算法所需的访问频率信息。</p>
<p>  记录LFU算法的所需信息时，它会用24 bits中的低8 bits作为计数器，来记录键值对的访问次数，同时它会用24 bits中的高16 bits，记录访问的时间戳。</p>
<pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token operator">|</span><span class="token operator">&lt;</span><span class="token separator comment">---</span>访问时间戳<span class="token separator comment">---</span><span class="token operator">></span><span class="token operator">|</span><span class="token operator">&lt;</span> 计数器 <span class="token operator">></span><span class="token operator">|</span> 

     <span class="token number">16</span> bits      <span class="token number">8</span> bits
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">+</span> Last decr time <span class="token operator">|</span> LOG_C  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="5-2-键值对访问频率初始化和更新"><a href="#5-2-键值对访问频率初始化和更新" class="headerlink" title="(5.2) 键值对访问频率初始化和更新"></a>(5.2) 键值对访问频率初始化和更新</h2><h3 id="5-2-1-初始化"><a href="#5-2-1-初始化" class="headerlink" title="(5.2.1) 初始化"></a>(5.2.1) 初始化</h3><p>  键值对 lru变量初始化是在 创建redisObject调用 <code>createObject</code> 函数时完成的。</p>
<p>主要分2步：<br>第一部是 lru 变量的高16位，是以1分钟为精度的 UNIX 时间戳。(LFUGetTimeInMinutes)<br>第二部是 lru 变量的低8位，被设置为宏定义 LFU_INIT_VAL，默认值为 5。</p>
<p>  源码如下</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/object.c</span>

<span class="token comment">/*
 * 创建一个redisObject对象
 *
 * @param type redisObject的类型
 * @param *ptr 值的指针
 */</span>
robj <span class="token operator">*</span><span class="token function">createObject</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 为redisObject结构体分配内存空间</span>
    robj <span class="token operator">*</span>o <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 省略部分代码 </span>

    <span class="token comment">// 将lru字段设置为当前的 lruclock（分钟分辨率），或者 LFU 计数器。 </span>
    <span class="token comment">// 判断内存过期策略</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 对应lfu </span>
        <span class="token comment">// LFU_INIT_VAL=5 对应二进制是 0101 </span>
        <span class="token comment">// 或运算  高16位是时间，低8位是次数， LFU_INIT_VAL = 5</span>
        o<span class="token operator">-></span>lru <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">LFUGetTimeInMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> LFU_INIT_VAL<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 对应lru </span>
        o<span class="token operator">-></span>lru <span class="token operator">=</span> <span class="token function">LRU_CLOCK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  counter会被初始化为<code>LFU_INIT_VAL</code>，默认5。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/evict.c</span>

<span class="token comment">/* ----------------------------------------------------------------------------
 * LFU (Least Frequently Used) implementation.
 * 
 * 为了实现 LFU（最不常用）驱逐策略，我们在每个对象中总共有 24 位空间，因为我们为此目的重新使用了 LRU 字段。
 *
 * 我们将 24 位分成两个字段：
 *
 *          16 bits      8 bits
 *     +----------------+--------+
 *     + Last decr time | LOG_C  |
 *     +----------------+--------+
 *
 * LOG_C 是提供访问频率指示的对数计数器。 
 * 然而，这个字段也必须递减，否则过去经常访问的键将永远保持这样的排名，而我们希望算法适应访问模式的变化。
 *
 * 因此，剩余的 16 位用于存储“递减时间”，
 * 这是一个精度降低的 Unix 时间(我们将 16 位时间转换为分钟，因为我们不关心回绕)，
 * 其中 LOG_C 计数器减半 如果它具有高值，或者如果它具有低值则只是递减。
 *
 * 新key不会从零开始，以便能够在被淘汰之前收集一些访问，因此它们从 COUNTER_INIT_VAL 开始。
 * COUNTER_INIT_VAL = 5
 * 因此从5(或具有较小值)开始的键在访问时递增的可能性非常高。
 *
 * 在递减期间，如果对数计数器的当前值大于5的两倍，则对数计数器的值减半，否则它只减一。
 * 
 * --------------------------------------------------------------------------*/</span>

<span class="token comment">/* 
 * 以分钟为单位返回当前时间，只取最低有效16位。 
 * 返回的时间适合存储为 LFU 实现的 LDT(最后递减时间)。
 */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">LFUGetTimeInMinutes</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 65535 = 2^16 - 1 对应二进制是 1111 1111 1111 1111</span>
    <span class="token comment">// (server.unixtime/60) &amp; 1111 1111 1111 1111</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>unixtime<span class="token operator">/</span><span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">65535</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="5-2-2-更新LFU值"><a href="#5-2-2-更新LFU值" class="headerlink" title="(5.2.2) 更新LFU值"></a>(5.2.2) 更新LFU值</h3><p>  当一个键值对被访问时，Redis 会调用 lookupKey 函数进行查找。lookupKey 函数会调用 updateLFU 函数来更新键值对的访问频率。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/db.c</span>

<span class="token comment">/* 
 * 访问对象时更新 LFU。
 * 首先，如果达到递减时间，则递减计数器。
 * 然后以对数方式递增计数器，并更新访问时间。
 */</span>
<span class="token keyword">void</span> <span class="token function">updateLFU</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 获取计数器</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> counter <span class="token operator">=</span> <span class="token function">LFUDecrAndReturn</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新计数器</span>
    counter <span class="token operator">=</span> <span class="token function">LFULogIncr</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    val<span class="token operator">-></span>lru <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">LFUGetTimeInMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> counter<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h4 id="5-2-2-1-递减计数器-LFUDecrAndReturn"><a href="#5-2-2-1-递减计数器-LFUDecrAndReturn" class="headerlink" title="(5.2.2.1) 递减计数器-LFUDecrAndReturn"></a>(5.2.2.1) 递减计数器-LFUDecrAndReturn</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * 如果达到对象递减时间，则 递减LFU计数器 但 不更新对象的LFU字段，
 * 我们在真正访问对象时以显式方式更新访问时间和计数器。
 * 
 * 并且我们将根据 经过的时间/server.lfu_decay_time 将计数器减半。
 * 返回对象频率计数器。
 * redis.conf配置文件里 lfu-decay-time 默认是 1
 * And we will times halve the counter according to the times of
 * elapsed time than server.lfu_decay_time.
 * 
 * 此函数用于扫描数据集以获得最佳对象
 *  适合：当我们检查候选对象时，如果需要，我们会递减扫描对象的计数器。
 */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">LFUDecrAndReturn</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">// 高16位存的是 上次访问时间(分钟级的) Last decr time </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ldt <span class="token operator">=</span> o<span class="token operator">-></span>lru <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">;</span>

    <span class="token comment">// 255 对应二进制 1111 1111 </span>
    <span class="token comment">// o->lru &amp; 1111 1111 相当于取低8位的值</span>
    <span class="token comment">// 获取计数器</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> counter <span class="token operator">=</span> o<span class="token operator">-></span>lru <span class="token operator">&amp;</span> <span class="token number">255</span><span class="token punctuation">;</span>

    <span class="token comment">// 0 &lt;= LFUTimeElapsed(ldt) &lt;  65535</span>
    <span class="token comment">// 过了的分钟数 / server.lfu_decay_time</span>
    <span class="token comment">// num_periods 是过了 n轮 衰减时间(lfu_decay_time)</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> num_periods <span class="token operator">=</span> server<span class="token punctuation">.</span>lfu_decay_time <span class="token operator">?</span> <span class="token function">LFUTimeElapsed</span><span class="token punctuation">(</span>ldt<span class="token punctuation">)</span> <span class="token operator">/</span> server<span class="token punctuation">.</span>lfu_decay_time <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果经过的轮数不为0 (超过1分钟了)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num_periods<span class="token punctuation">)</span> 
        <span class="token comment">// 如果 n轮衰减 > 访问次数，counter设置为0，相当于重新开始计算</span>
        <span class="token comment">// 否则，n轮衰减 &lt;= 访问次数，counter设置为 counter - num_periods，相当于每过1轮衰减时间(lfu_decay_time)，减1</span>
        counter <span class="token operator">=</span> <span class="token punctuation">(</span>num_periods <span class="token operator">></span> counter<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> counter <span class="token operator">-</span> num_periods<span class="token punctuation">;</span>

    <span class="token comment">// 如果没有超过1分钟，num_periods=0，直接返回counter</span>
    <span class="token comment">// 如果超过1分钟，num_periods！=0，至少过了1轮衰减时间(lfu_decay_time)了，更新counter后返回</span>
    <span class="token keyword">return</span> counter<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  <code>LFUDecrAndReturn</code> 得到的计数结果</p>
<ol>
<li>如果在当前分钟时间戳内，counter不变</li>
<li>如果不在当前分钟时间戳内，每过1轮衰减时间(lfu_decay_time)，counter减1 (代码里是过了num_periods轮，减num_periods)</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 
 * 计算过了多少分钟
 * 
 * 给定对象的上次访问时间，计算自上次访问以来经过的最小分钟数。 
 * 处理溢出(ldt 大于当前 16 位分钟时间)，将时间视为正好回绕一次。
 * 
 * @param ldt 上一次访问的时间(分钟级)
 */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">LFUTimeElapsed</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> ldt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 获取分钟级时间戳</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token function">LFUGetTimeInMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 计算过了多少分钟</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">>=</span> ldt<span class="token punctuation">)</span> <span class="token keyword">return</span> now<span class="token operator">-</span>ldt<span class="token punctuation">;</span>

    <span class="token comment">// 实际上now永远是在ldt(上一次访问时间之后)</span>
    <span class="token comment">// 但是现在 now &lt; ldt，不符合预期 </span>
    <span class="token comment">// ldt是 (server.unixtime/60) &amp; 1111 1111 1111 1111 得到的，相当于取余，也就是至少过了1轮了 </span>
    <span class="token comment">// 假设 ldt = 65534  now = 1，其实过了2分钟</span>
    <span class="token keyword">return</span> <span class="token number">65535</span><span class="token operator">-</span>ldt<span class="token operator">+</span>now<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h4 id="5-2-2-2-更新LFU计数器-LFULogIncr"><a href="#5-2-2-2-更新LFU计数器-LFULogIncr" class="headerlink" title="(5.2.2.2) 更新LFU计数器-LFULogIncr"></a>(5.2.2.2) 更新LFU计数器-LFULogIncr</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 
 * 以对数方式递增计数器。 当前计数器值越大，它真正实现的可能性就越小。 在255时饱和。
 *
 * Logarithmically increment a counter. 
 * The greater is the current counter value
 * the less likely is that it gets really implemented. 
 * Saturate it at 255. 
 */</span>
<span class="token class-name">uint8_t</span> <span class="token function">LFULogIncr</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> counter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 最大255</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">255</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取一个随机数</span>
    <span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>RAND_MAX<span class="token punctuation">;</span>

    <span class="token comment">// 基础值 = counter - 5</span>
    <span class="token keyword">double</span> baseval <span class="token operator">=</span> counter <span class="token operator">-</span> LFU_INIT_VAL<span class="token punctuation">;</span>
    <span class="token comment">// 最小=0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>baseval <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> baseval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 取对数 </span>
    <span class="token keyword">double</span> p <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span><span class="token punctuation">(</span>baseval<span class="token operator">*</span>server<span class="token punctuation">.</span>lfu_log_factor<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 随机数 &lt; 对数时，计数器+1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> p<span class="token punctuation">)</span> counter<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> counter<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  counter并不是简单的访问一次就+1，而是采用了一个0-1之间的p因子控制增长。</p>
<p>  <img src="/img/database/redis/cache-eviction/lfu/redis-lfu-log-1.png" alt="对数"></p>
<p>取一个0-1之间的随机数r与p比较，当<code>r &lt; p</code>时，才增加counter<br><code>p</code>取决于当前counter值与<code>lfu_log_factor</code>因子，<code>counter</code>值与<code>lfu_log_factor</code>因子越大，<code>p</code>越小，<code>r&lt;p</code>的概率也越小，counter增长的概率也就越小。</p>
<p>  增长情况如下</p>
<pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> factor <span class="token operator">|</span> <span class="token number">100</span> hits   <span class="token operator">|</span> <span class="token number">1000</span> hits  <span class="token operator">|</span> <span class="token number">100K</span> hits  <span class="token operator">|</span> <span class="token number">1M</span> hits    <span class="token operator">|</span> <span class="token number">10M</span> hits   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> <span class="token number">0</span>      <span class="token operator">|</span> <span class="token number">104</span>        <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> <span class="token number">1</span>      <span class="token operator">|</span> <span class="token number">18</span>         <span class="token operator">|</span> <span class="token number">49</span>         <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> <span class="token number">10</span>     <span class="token operator">|</span> <span class="token number">10</span>         <span class="token operator">|</span> <span class="token number">18</span>         <span class="token operator">|</span> <span class="token number">142</span>        <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> <span class="token number">100</span>    <span class="token operator">|</span> <span class="token number">8</span>          <span class="token operator">|</span> <span class="token number">11</span>         <span class="token operator">|</span> <span class="token number">49</span>         <span class="token operator">|</span> <span class="token number">143</span>        <span class="token operator">|</span> <span class="token number">255</span>        <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="5-3-LFU算法淘汰数据"><a href="#5-3-LFU算法淘汰数据" class="headerlink" title="(5.3) LFU算法淘汰数据"></a>(5.3) LFU算法淘汰数据</h2><p>主要有三步<br>第一步，调用 getMaxmemoryState 函数计算待释放的内存空间；<br>第二步，调用 evictionPoolPopulate 函数随机采样键值对，并插入到待淘汰集合 EvictionPoolLRU 中；<br>第三步，遍历待淘汰集合 EvictionPoolLRU，选择实际被淘汰数据，并删除。</p>
<h3 id="5-3-1-判断当前内存使用情况-getMaxmemoryState"><a href="#5-3-1-判断当前内存使用情况-getMaxmemoryState" class="headerlink" title="(5.3.1) 判断当前内存使用情况-getMaxmemoryState"></a>(5.3.1) 判断当前内存使用情况-getMaxmemoryState</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/evict.c</span>

<span class="token comment">/* Get the memory status from the point of view of the maxmemory directive:
 * if the memory used is under the maxmemory setting then C_OK is returned.
 * Otherwise, if we are over the memory limit, the function returns
 * C_ERR.
 *
 * The function may return additional info via reference, only if the
 * pointers to the respective arguments is not NULL. Certain fields are
 * populated only when C_ERR is returned:
 *
 *  'total'     total amount of bytes used.
 *              (Populated both for C_ERR and C_OK)
 *
 *  'logical'   the amount of memory used minus the slaves/AOF buffers.
 *              (Populated when C_ERR is returned)
 *
 *  'tofree'    the amount of memory that should be released
 *              in order to return back into the memory limits.
 *              (Populated when C_ERR is returned)
 *
 *  'level'     this usually ranges from 0 to 1, and reports the amount of
 *              memory currently used. May be > 1 if we are over the memory
 *              limit.
 *              (Populated both for C_ERR and C_OK)
 */</span>
<span class="token keyword">int</span> <span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span>total<span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span>logical<span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span>tofree<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">size_t</span> mem_reported<span class="token punctuation">,</span> mem_used<span class="token punctuation">,</span> mem_tofree<span class="token punctuation">;</span>

    <span class="token comment">/* Check if we are over the memory usage limit. If we are not, no need
     * to subtract the slaves output buffers. We can just return ASAP. */</span>
    mem_reported <span class="token operator">=</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>total<span class="token punctuation">)</span> <span class="token operator">*</span>total <span class="token operator">=</span> mem_reported<span class="token punctuation">;</span>

    <span class="token comment">/* We may return ASAP if there is no need to compute the level. */</span>
    <span class="token keyword">int</span> return_ok_asap <span class="token operator">=</span> <span class="token operator">!</span>server<span class="token punctuation">.</span>maxmemory <span class="token operator">||</span> mem_reported <span class="token operator">&lt;=</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>return_ok_asap <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>level<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">/* Remove the size of slaves output buffers and AOF buffer from the
     * count of used memory. */</span>
    mem_used <span class="token operator">=</span> mem_reported<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> overhead <span class="token operator">=</span> <span class="token function">freeMemoryGetNotCountedMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mem_used <span class="token operator">=</span> <span class="token punctuation">(</span>mem_used <span class="token operator">></span> overhead<span class="token punctuation">)</span> <span class="token operator">?</span> mem_used<span class="token operator">-</span>overhead <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">/* Compute the ratio of memory usage. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">*</span>level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">*</span>level <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>mem_used <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>return_ok_asap<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">/* Check if we are still over the memory limit. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mem_used <span class="token operator">&lt;=</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">/* Compute how much memory we need to free. */</span>
    mem_tofree <span class="token operator">=</span> mem_used <span class="token operator">-</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>logical<span class="token punctuation">)</span> <span class="token operator">*</span>logical <span class="token operator">=</span> mem_used<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tofree<span class="token punctuation">)</span> <span class="token operator">*</span>tofree <span class="token operator">=</span> mem_tofree<span class="token punctuation">;</span>

    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="5-3-2-更新待淘汰的候选键值对集合-evictionPoolPopulate"><a href="#5-3-2-更新待淘汰的候选键值对集合-evictionPoolPopulate" class="headerlink" title="(5.3.2) 更新待淘汰的候选键值对集合-evictionPoolPopulate"></a>(5.3.2) 更新待淘汰的候选键值对集合-evictionPoolPopulate</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/evict.c</span>

<span class="token comment">/* This is an helper function for freeMemoryIfNeeded(), it is used in order
 * to populate the evictionPool with a few entries every time we want to
 * expire a key. Keys with idle time smaller than one of the current
 * keys are added. Keys are always added if there are free entries.
 *
 * We insert keys on place in ascending order, so keys with the smaller
 * idle time are on the left, and keys with the higher idle time on the
 * right. */</span>

<span class="token keyword">void</span> <span class="token function">evictionPoolPopulate</span><span class="token punctuation">(</span><span class="token keyword">int</span> dbid<span class="token punctuation">,</span> dict <span class="token operator">*</span>sampledict<span class="token punctuation">,</span> dict <span class="token operator">*</span>keydict<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token operator">*</span>pool<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> count<span class="token punctuation">;</span>
    dictEntry <span class="token operator">*</span>samples<span class="token punctuation">[</span>server<span class="token punctuation">.</span>maxmemory_samples<span class="token punctuation">]</span><span class="token punctuation">;</span>

    count <span class="token operator">=</span> <span class="token function">dictGetSomeKeys</span><span class="token punctuation">(</span>sampledict<span class="token punctuation">,</span>samples<span class="token punctuation">,</span>server<span class="token punctuation">.</span>maxmemory_samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> idle<span class="token punctuation">;</span>
        sds key<span class="token punctuation">;</span>
        robj <span class="token operator">*</span>o<span class="token punctuation">;</span>
        dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>

        de <span class="token operator">=</span> samples<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        key <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* If the dictionary we are sampling from is not the main
         * dictionary (but the expires one) we need to lookup the key
         * again in the key dictionary to obtain the value object. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">!=</span> MAXMEMORY_VOLATILE_TTL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sampledict <span class="token operator">!=</span> keydict<span class="token punctuation">)</span> de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>keydict<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            o <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Calculate the idle time according to the policy. This is called
         * idle just because the code initially handled LRU, but is in fact
         * just a score where an higher score means better candidate. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LRU<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            idle <span class="token operator">=</span> <span class="token function">estimateObjectIdleTime</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* When we use an LRU policy, we sort the keys by idle time
             * so that we expire keys starting from greater idle time.
             * However when the policy is an LFU one, we have a frequency
             * estimation, and we want to evict keys with lower frequency
             * first. So inside the pool we put objects using the inverted
             * frequency subtracting the actual frequency to the maximum
             * frequency of 255. */</span>
            idle <span class="token operator">=</span> <span class="token number">255</span><span class="token operator">-</span><span class="token function">LFUDecrAndReturn</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_VOLATILE_TTL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* In this case the sooner the expire the better. */</span>
            idle <span class="token operator">=</span> ULLONG_MAX <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown eviction policy in evictionPoolPopulate()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Insert the element inside the pool.
         * First, find the first empty bucket or the first populated
         * bucket that has an idle time smaller than our idle time. */</span>
        k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> EVPOOL_SIZE <span class="token operator">&amp;&amp;</span>
               pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span>
               pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>idle <span class="token operator">&lt;</span> idle<span class="token punctuation">)</span> k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pool<span class="token punctuation">[</span>EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* Can't insert if the element is &lt; the worst element we have
             * and there are no empty buckets. */</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> EVPOOL_SIZE <span class="token operator">&amp;&amp;</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* Inserting into empty position. No setup needed before insert. */</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* Inserting in the middle. Now k points to the first element
             * greater than the element to insert.  */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">/* Free space on the right? Insert at k shifting
                 * all the elements from k to end to the right. */</span>

                <span class="token comment">/* Save SDS before overwriting. */</span>
                sds cached <span class="token operator">=</span> pool<span class="token punctuation">[</span>EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">;</span>
                <span class="token function">memmove</span><span class="token punctuation">(</span>pool<span class="token operator">+</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>pool<span class="token operator">+</span>k<span class="token punctuation">,</span>
                    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>EVPOOL_SIZE<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached <span class="token operator">=</span> cached<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">/* No free space on right? Insert at k-1 */</span>
                k<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token comment">/* Shift all elements on the left of k (included) to the
                 * left, so we discard the element with smaller idle time. */</span>
                sds cached <span class="token operator">=</span> pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">;</span> <span class="token comment">/* Save SDS before overwriting. */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">)</span> <span class="token function">sdsfree</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">memmove</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span>pool<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
                pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached <span class="token operator">=</span> cached<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Try to reuse the cached SDS string allocated in the pool entry,
         * because allocating and deallocating this object is costly
         * (according to the profiler, not my fantasy. Remember:
         * premature optimization bla bla bla. */</span>
        <span class="token keyword">int</span> klen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>klen <span class="token operator">></span> EVPOOL_CACHED_SDS_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token function">sdsdup</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">memcpy</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">,</span>key<span class="token punctuation">,</span>klen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sdssetlen</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">,</span>klen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>idle <span class="token operator">=</span> idle<span class="token punctuation">;</span>
        pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid <span class="token operator">=</span> dbid<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-3-3-选择被淘汰的键值对并删除-freeMemoryIfNeeded"><a href="#5-3-3-选择被淘汰的键值对并删除-freeMemoryIfNeeded" class="headerlink" title="(5.3.3) 选择被淘汰的键值对并删除-freeMemoryIfNeeded"></a>(5.3.3) 选择被淘汰的键值对并删除-freeMemoryIfNeeded</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: src/evict.c</span>

<span class="token comment">/* This function is periodically called to see if there is memory to free
 * according to the current "maxmemory" settings. In case we are over the
 * memory limit, the function will try to free some memory to return back
 * under the limit.
 *
 * The function returns C_OK if we are under the memory limit or if we
 * were over the limit, but the attempt to free memory was successful.
 * Otherwise if we are over the memory limit, but not enough memory
 * was freed to return back under the limit, the function returns C_ERR. */</span>
<span class="token keyword">int</span> <span class="token function">freeMemoryIfNeeded</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> keys_freed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/* By default replicas should ignore maxmemory
     * and just be masters exact copies. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>repl_slave_ignore_maxmemory<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token class-name">size_t</span> mem_reported<span class="token punctuation">,</span> mem_tofree<span class="token punctuation">,</span> mem_freed<span class="token punctuation">;</span>
    <span class="token class-name">mstime_t</span> latency<span class="token punctuation">,</span> eviction_latency<span class="token punctuation">,</span> lazyfree_latency<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> delta<span class="token punctuation">;</span>
    <span class="token keyword">int</span> slaves <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>

    <span class="token comment">/* When clients are paused the dataset should be static not just from the
     * POV of clients not being able to write, but also from the POV of
     * expires and evictions of keys not being performed. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientsArePaused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_reported<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>mem_tofree<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span>
        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    mem_freed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_NO_EVICTION<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> cant_free<span class="token punctuation">;</span> <span class="token comment">/* We need to free memory, but policy forbids. */</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>mem_freed <span class="token operator">&lt;</span> mem_tofree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> next_db <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        sds bestkey <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> bestdbid<span class="token punctuation">;</span>
        redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>
        dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
        dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> <span class="token punctuation">(</span>MAXMEMORY_FLAG_LRU<span class="token operator">|</span>MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token operator">||</span>
            server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_VOLATILE_TTL<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token operator">*</span>pool <span class="token operator">=</span> EvictionPoolLRU<span class="token punctuation">;</span>

            <span class="token keyword">while</span><span class="token punctuation">(</span>bestkey <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_keys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> keys<span class="token punctuation">;</span>

                <span class="token comment">/* We don't want to make local-db choices when expiring keys,
                 * so to start populate the eviction pool sampling keys from
                 * every DB. */</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>i<span class="token punctuation">;</span>
                    dict <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_ALLKEYS<span class="token punctuation">)</span> <span class="token operator">?</span>
                            db<span class="token operator">-></span>dict <span class="token operator">:</span> db<span class="token operator">-></span>expires<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>keys <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token function">evictionPoolPopulate</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> dict<span class="token punctuation">,</span> db<span class="token operator">-></span>dict<span class="token punctuation">,</span> pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        total_keys <span class="token operator">+=</span> keys<span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>total_keys<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">/* No keys to evict. */</span>

                <span class="token comment">/* Go backward from best to worst element to evict. */</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    bestdbid <span class="token operator">=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">;</span>

                    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_ALLKEYS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">]</span><span class="token punctuation">.</span>dict<span class="token punctuation">,</span>
                            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">]</span><span class="token punctuation">.</span>expires<span class="token punctuation">,</span>
                            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>

                    <span class="token comment">/* Remove the entry from the pool. */</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">)</span>
                        <span class="token function">sdsfree</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                    pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>idle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

                    <span class="token comment">/* If the key exists, is our pick. Otherwise it is
                     * a ghost and we need to try the next element. */</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        bestkey <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                        <span class="token comment">/* Ghost... Iterate again. */</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* volatile-random and allkeys-random policy */</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_ALLKEYS_RANDOM <span class="token operator">||</span>
                 server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_VOLATILE_RANDOM<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">/* When evicting a random key, we try to evict a key for
             * each DB, so we use the static 'next_db' variable to
             * incrementally visit all DBs. */</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span>next_db<span class="token punctuation">)</span> <span class="token operator">%</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span>
                db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>j<span class="token punctuation">;</span>
                dict <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">==</span> MAXMEMORY_ALLKEYS_RANDOM<span class="token punctuation">)</span> <span class="token operator">?</span>
                        db<span class="token operator">-></span>dict <span class="token operator">:</span> db<span class="token operator">-></span>expires<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    de <span class="token operator">=</span> <span class="token function">dictGetRandomKey</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    bestkey <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    bestdbid <span class="token operator">=</span> j<span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* Finally remove the selected key. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bestkey<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>bestdbid<span class="token punctuation">;</span>
            robj <span class="token operator">*</span>keyobj <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span>bestkey<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>bestkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">propagateExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">,</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">/* We compute the amount of memory freed by db*Delete() alone.
             * It is possible that actually the memory needed to propagate
             * the DEL in AOF and replication link is greater than the one
             * we are freeing removing the key, but we can't account for
             * that otherwise we would never exit the loop.
             *
             * Same for CSC invalidation messages generated by signalModifiedKey.
             *
             * AOF and Output buffer memory will be freed eventually so
             * we only care about memory used by the key space. */</span>
            delta <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>eviction_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction<span class="token punctuation">)</span>
                <span class="token function">dbAsyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">dbSyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>eviction_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"eviction-del"</span><span class="token punctuation">,</span>eviction_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
            delta <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            mem_freed <span class="token operator">+=</span> delta<span class="token punctuation">;</span>
            server<span class="token punctuation">.</span>stat_evictedkeys<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token function">signalModifiedKey</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span>NOTIFY_EVICTED<span class="token punctuation">,</span> <span class="token string">"evicted"</span><span class="token punctuation">,</span>
                keyobj<span class="token punctuation">,</span> db<span class="token operator">-></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">decrRefCount</span><span class="token punctuation">(</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            keys_freed<span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token comment">/* When the memory to free starts to be big enough, we may
             * start spending so much time here that is impossible to
             * deliver data to the slaves fast enough, so we force the
             * transmission here inside the loop. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>slaves<span class="token punctuation">)</span> <span class="token function">flushSlavesOutputBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">/* Normally our stop condition is the ability to release
             * a fixed, pre-computed amount of memory. However when we
             * are deleting objects in another thread, it's better to
             * check, from time to time, if we already reached our target
             * memory, since the "mem_freed" amount is computed only
             * across the dbAsyncDelete() call, while the thread can
             * release the memory all the time. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>keys_freed <span class="token operator">%</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token comment">/* Let's satisfy our stop condition. */</span>
                    mem_freed <span class="token operator">=</span> mem_tofree<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">goto</span> cant_free<span class="token punctuation">;</span> <span class="token comment">/* nothing to free... */</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    result <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>

cant_free<span class="token operator">:</span>
    <span class="token comment">/* We are here if we are not able to reclaim memory. There is only one
     * last thing we can try: check if the lazyfree thread has jobs in queue
     * and wait... */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>lazyfree_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">bioPendingJobsOfType</span><span class="token punctuation">(</span>BIO_LAZY_FREE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>lazyfree_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"eviction-lazyfree"</span><span class="token punctuation">,</span>lazyfree_latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">"eviction-cycle"</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/294640">Redis 核心技术与实战 - 24 | 替换策略：缓存满了怎么办？</a><br>[2] <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/297270">Redis 核心技术与实战 - 27 | 缓存被污染了，该怎么办？</a><br>[3] <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/412164">Redis 源码剖析与实战 - 15 | 为什么LRU算法原理和代码实现不一样？</a><br>[4] <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/413038">Redis 源码剖析与实战 - 16 | LFU算法和其他算法相比有优势吗？</a><br>[5] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/linxiyue/p/10955533.html">Redis中的LFU算法</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/26/redis-command-execution-process/" rel="prev" title="Redis命令执行流程">
                  <i class="fa fa-angle-left"></i> Redis命令执行流程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/26/elasticsearch-index-model/" rel="next" title="elasticsearch索引模型">
                  elasticsearch索引模型 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">WKQ</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://fantastic-paletas-170a7a.netlify.app/.netlify/functions/comment","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎评论","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2022/03/06/redis-cache-eviction-strategy/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
