<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"weikeqin.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="RedisIO模型   Redis服务器端单线程可以达到每秒可以达到数万QPS的处理能力。如此高性能的其中一个原因就是运用了Linux提供的IO多路复用机制epoll。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis高性能IO模型">
<meta property="og:url" content="http://weikeqin.com/2022/01/08/redis-io-model/index.html">
<meta property="og:site_name" content="天道酬勤">
<meta property="og:description" content="RedisIO模型   Redis服务器端单线程可以达到每秒可以达到数万QPS的处理能力。如此高性能的其中一个原因就是运用了Linux提供的IO多路复用机制epoll。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://weikeqin.com/img/database/redis/io-model/linux-io-multiplexing-epoll.png">
<meta property="og:image" content="http://weikeqin.com/img/database/redis/io-model/redis_server-main-init_server.png">
<meta property="og:image" content="http://weikeqin.com/img/linux/network/tcp-server-work-process-simple.png">
<meta property="og:image" content="http://weikeqin.com/img/database/redis/io-model/redis-io-model-detail.png">
<meta property="article:published_time" content="2022-01-08T00:56:06.000Z">
<meta property="article:modified_time" content="2023-01-27T15:20:59.505Z">
<meta property="article:author" content="WKQ">
<meta property="article:tag" content="io">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://weikeqin.com/img/database/redis/io-model/linux-io-multiplexing-epoll.png">


<link rel="canonical" href="http://weikeqin.com/2022/01/08/redis-io-model/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://weikeqin.com/2022/01/08/redis-io-model/","path":"2022/01/08/redis-io-model/","title":"Redis高性能IO模型"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis高性能IO模型 | 天道酬勤</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113485469-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-113485469-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?d1ad0ae2a9976c44d556abc07cda1365"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">天道酬勤</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Redis%E6%BA%90%E7%A0%81%E6%A6%82%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">(1) Redis源码概览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%90%AF%E5%8A%A8RedisServer%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.</span> <span class="nav-text">(1.1) 启动RedisServer初始化配置及资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="nav-number">1.2.</span> <span class="nav-text">(1.2) 循环处理请求</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-RedisServer%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">(2) RedisServer网络请求处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%BB%91%E5%AE%9A%E5%9C%B0%E5%9D%80%E5%B9%B6%E7%9B%91%E5%90%AC%E5%A5%97%E6%8E%A5%E5%AD%97-bind-listen"><span class="nav-number">2.1.</span> <span class="nav-text">(2.1) 绑定地址并监听套接字(bind listen)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-accept"><span class="nav-number">2.2.</span> <span class="nav-text">(2.2) 和客户端建立连接(accept)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E6%8E%A5%E6%94%B6tcp%E8%AF%B7%E6%B1%82-anetTcpAccept"><span class="nav-number">2.2.1.</span> <span class="nav-text">(2.2.1) 接收tcp请求-anetTcpAccept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E6%8E%A5%E6%94%B6%E5%85%AC%E5%85%B1%E5%A4%84%E7%90%86%E5%99%A8-acceptCommonHandler"><span class="nav-number">2.2.2.</span> <span class="nav-text">(2.2.2) 接收公共处理器-acceptCommonHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-1-connCreateAcceptedSocket"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">(2.2.2.1) connCreateAcceptedSocket()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-2-%E5%88%9B%E5%BB%BAredisClient%E5%AF%B9%E8%B1%A1-createClient"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">(2.2.2.2) 创建redisClient对象-createClient()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-3-%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82-connAccept"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">(2.2.2.3) 接收请求-connAccept()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E4%BB%8E%E8%BF%9E%E6%8E%A5%E7%9A%84socket%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE-recv-read"><span class="nav-number">2.3.</span> <span class="nav-text">(2.3) 从连接的socket读取客户端发送的数据(recv&#x2F;read)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%A4%84%E7%90%86%E8%AF%BB%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">2.4.</span> <span class="nav-text">(2.4) 处理读到的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-getCommand"><span class="nav-number">2.4.1.</span> <span class="nav-text">(2.4.1) getCommand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-setCommand"><span class="nav-number">2.4.2.</span> <span class="nav-text">(2.4.2) setCommand</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C-send"><span class="nav-number">2.5.</span> <span class="nav-text">(2.5) 给客户端返回结果(send)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E5%9B%9E%E5%A4%8D%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%86%99%E5%85%A5%E5%88%B0%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E5%91%A2%EF%BC%9F"><span class="nav-number">2.5.1.</span> <span class="nav-text">(2.5.1) 回复列表中的数据什么时候写入到输出缓冲区呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E5%86%99%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8-sendReplyToClient"><span class="nav-number">2.5.2.</span> <span class="nav-text">(2.5.2) 写事件处理器-sendReplyToClient</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">2.5.3.</span> <span class="nav-text">(2.5.3) 把数据写入客户端的输出缓冲区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-RedisServer%E9%87%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">(3) RedisServer里IO多路复用代码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%88%9B%E5%BB%BAepoll-aeCreateEventLoop"><span class="nav-number">3.1.</span> <span class="nav-text">(3.1) 创建epoll-aeCreateEventLoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-aeCreateFileEvent"><span class="nav-number">3.2.</span> <span class="nav-text">(3.2) 注册事件及回调函数-aeCreateFileEvent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E8%8E%B7%E5%8F%96%E5%B0%B1%E7%BB%AAsocket%E5%B9%B6%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6-aeMain"><span class="nav-number">3.3.</span> <span class="nav-text">(3.3) 获取就绪socket并处理事件-aeMain()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-RedisServer-IO%E6%A8%A1%E5%9E%8B%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88"><span class="nav-number">4.</span> <span class="nav-text">(4) RedisServer-IO模型流程概览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%9D%E8%80%83"><span class="nav-number">5.</span> <span class="nav-text">思考</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="nav-number">5.1.</span> <span class="nav-text">Redis有哪些潜在的性能瓶颈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-6-0%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">Redis 6.0版本为什么又引入了多线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WKQ</p>
  <div class="site-description" itemprop="description">不积跬步无以至千里</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">296</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:weikeqin.cn@gmail.com" title="E-Mail → mailto:weikeqin.cn@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/u/0/107737814703120725006" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;u&#x2F;0&#x2F;107737814703120725006" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/wkq278276130" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;wkq278276130" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/keqin.wei.5" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;keqin.wei.5" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/8054088/wkq" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;8054088&#x2F;wkq" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weikeqin.com/2022/01/08/redis-io-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WKQ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天道酬勤">
      <meta itemprop="description" content="不积跬步无以至千里">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis高性能IO模型 | 天道酬勤">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis高性能IO模型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-08 08:56:06" itemprop="dateCreated datePublished" datetime="2022-01-08T08:56:06+08:00">2022-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-27 23:20:59" itemprop="dateModified" datetime="2023-01-27T23:20:59+08:00">2023-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/database/" itemprop="url" rel="index"><span itemprop="name">database</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>32k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>29 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>  RedisIO模型</p>
<p>  Redis服务器端单线程可以达到每秒可以达到数万QPS的处理能力。如此高性能的其中一个原因就是运用了Linux提供的IO多路复用机制epoll。</p>
<p>  <img src="/img/database/redis/io-model/linux-io-multiplexing-epoll.png" alt="IO模型"></p>
<span id="more"></span>

<p>  源码地址  <a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/6.0/src/server.c">https://github.com/redis/redis/blob/6.0/src/server.c</a> </p>
<h1 id="1-Redis源码概览"><a href="#1-Redis源码概览" class="headerlink" title="(1) Redis源码概览"></a>(1) Redis源码概览</h1><pre class="line-numbers language-c++++" data-language="c++++"><code class="language-c++++">&#x2F;&#x2F;file: src&#x2F;server.c

&#x2F;&#x2F; #L5297  5297行
int main(int argc, char **argv) &#123;

  &#x2F;&#x2F; 省略部分代码... 

  &#x2F;&#x2F; 1. 启动RedisServer时 初始化配置及资源
  initServer();

  &#x2F;&#x2F; 2. 循环处理请求及事件，直到服务器关闭为止
  aeMain(server.el); 

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="1-1-启动RedisServer初始化配置及资源"><a href="#1-1-启动RedisServer初始化配置及资源" class="headerlink" title="(1.1) 启动RedisServer初始化配置及资源"></a>(1.1) 启动RedisServer初始化配置及资源</h2><p>在 initServer 这个函数内，Redis 做了这么三件重要的事情。</p>
<p> <img src="/img/database/redis/io-model/redis_server-main-init_server.png" alt="RedisServer启动initServer流程"></p>
<p>1、创建一个epoll对象<br>2、对配置的监听端口进行listen<br>3、把 listen socket 让 epoll 给管理起来</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void initServer(void) &#123;

    &#x2F;&#x2F; 1. 创建epoll
    server.el &#x3D; aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);

    &#x2F;&#x2F; 2. 监听端口
    listenToPort(server.port,server.ipfd,&amp;server.ipfd_count)

    &#x2F;&#x2F; 3. 注册accept事件处理器 (只是注册 后面会用到)
    for (j &#x3D; 0; j &lt; server.ipfd_count; j++) &#123;
        aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,
            acceptTcpHandler,NULL)
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="1-2-循环处理请求"><a href="#1-2-循环处理请求" class="headerlink" title="(1.2) 循环处理请求"></a>(1.2) 循环处理请求</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;ae.c 

&#x2F;**
 * 循环处理事件
 * 
 * @param *eventLoop 
 *&#x2F; 
void aeMain(aeEventLoop *eventLoop) &#123;
    eventLoop-&gt;stop &#x3D; 0;
    &#x2F;&#x2F; 循环处理事件
    while (!eventLoop-&gt;stop) &#123;
        &#x2F;&#x2F; 处理事件
        aeProcessEvents(eventLoop, AE_ALL_EVENTS|
                                   AE_CALL_BEFORE_SLEEP|
                                   AE_CALL_AFTER_SLEEP);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;ae.c 

&#x2F;**
 * 处理事件
 * 
 * @param *eventLoop
 * @param flags
 *&#x2F; 
int aeProcessEvents(aeEventLoop *eventLoop, int flags)
&#123;
    &#x2F;&#x2F; 省略部分细节...

    &#x2F;&#x2F; 调用多路复用API获取就绪事件
    numevents &#x3D; aeApiPoll(eventLoop, tvp);

    &#x2F;&#x2F; 处理写事件
    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);
    &#x2F;&#x2F; 处理读事件
    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);
                        
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>  其实整个 Redis 的工作过程，就只需要理解清楚 main 函数中调用的 <code>initServer</code> 和 <code>aeMain</code> 这两个函数就足够了。</p>
<br>

<h1 id="2-RedisServer网络请求处理流程"><a href="#2-RedisServer网络请求处理流程" class="headerlink" title="(2) RedisServer网络请求处理流程"></a>(2) RedisServer网络请求处理流程</h1><p>  <img src="/img/linux/network/tcp-server-work-process-simple.png" alt="redis网络请求处理流程"></p>
<h2 id="2-1-绑定地址并监听套接字-bind-listen"><a href="#2-1-绑定地址并监听套接字-bind-listen" class="headerlink" title="(2.1) 绑定地址并监听套接字(bind listen)"></a>(2.1) 绑定地址并监听套接字(bind listen)</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file:  src&#x2F;server.c 

&#x2F;&#x2F; 监听端口
&#x2F;**
 * @param port
 * @param *fds
 * @param *count
 *&#x2F;
int listenToPort(int port, int *fds, int *count) &#123;

    &#x2F;&#x2F; ... 

    for (j &#x3D; 0; j &lt; server.bindaddr_count || j &#x3D;&#x3D; 0; j++) &#123;

        &#x2F;&#x2F; ...  省略 绑定IPV6 IPV4的细节  anetTcp6Server  anetTcpServer

        &#x2F;&#x2F; 绑定
        fds[*count] &#x3D; anetTcpServer(server.neterr,port,NULL,
                    server.tcp_backlog);

        &#x2F;&#x2F; ...  

    &#125;
    return C_OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  Redis 是支持开启多个端口的，所以在 listenToPort 中我们看到是启用一个循环来调用 anetTcpServer。<br>  在 anetTcpServer 中，逐步会展开调用，直到执行到 bind 和 listen 系统调用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file:  src&#x2F;anet.c 

&#x2F;**
 * @param *err
 * @param port
 * @param *bindaddr
 * @param backlog
 *&#x2F;
int anetTcpServer(char *err, int port, char *bindaddr, int backlog)
&#123;
    return _anetTcpServer(err, port, bindaddr, AF_INET, backlog);
&#125;


&#x2F;**
 * @param *err
 * @param port
 * @param *bindaddr
 * @param af
 * @param backlog
 *&#x2F;
static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)
&#123;
    int s &#x3D; -1, rv;
    char _port[6];  &#x2F;* strlen(&quot;65535&quot;) *&#x2F;
    struct addrinfo hints, *servinfo, *p;

    &#x2F;&#x2F; 创建套接字
    s &#x3D; socket(p-&gt;ai_family,p-&gt;ai_socktype,p-&gt;ai_protocol)

    &#x2F;&#x2F; 设置端口重用
    anetSetReuseAddr(err,s)

    &#x2F;&#x2F; 监听
    anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * 监听
 * 
 * @param *err
 * @param s 对应创建的套接字fd
 * @param *sa socket地址信息 (协议 地址)
 * @param len
 * @param backlog 
 *&#x2F;
static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) &#123;
    &#x2F;&#x2F; 绑定ip端口
    bind(s,sa,len)

    &#x2F;&#x2F; 监听套接字
    listen(s, backlog)

    return ANET_OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>


<h2 id="2-2-和客户端建立连接-accept"><a href="#2-2-和客户端建立连接-accept" class="headerlink" title="(2.2) 和客户端建立连接(accept)"></a>(2.2) 和客户端建立连接(accept)</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c 

&#x2F;**
 * 接收tcp处理器
 * 
 * @param *el
 * @param fd
 * @param *privdata
 * @param mask
 *&#x2F;
void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) &#123;

        &#x2F;&#x2F; ... 

        &#x2F;&#x2F; 接收tcp请求
        cfd &#x3D; anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &amp;cport);

        &#x2F;&#x2F; ... 

        &#x2F;&#x2F; 接收通用处理
        acceptCommonHandler(connCreateAcceptedSocket(cfd),0,cip);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="2-2-1-接收tcp请求-anetTcpAccept"><a href="#2-2-1-接收tcp请求-anetTcpAccept" class="headerlink" title="(2.2.1) 接收tcp请求-anetTcpAccept"></a>(2.2.1) 接收tcp请求-anetTcpAccept</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;anet.c 

&#x2F;**
 * 接收tcp请求 
 * 
 * @param *err
 * @param s fd
 * @param *ip
 * @param ip_len
 * @param *port 
 *&#x2F;
int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) &#123;
    int fd;
    struct sockaddr_storage sa; &#x2F;&#x2F; 套接字地址存储结构体 
    socklen_t salen &#x3D; sizeof(sa);

    &#x2F;&#x2F; 接收请求
    fd &#x3D; anetGenericAccept(err,s,(struct sockaddr*)&amp;sa,&amp;salen)
        
    &#x2F;&#x2F; ... 
    return fd;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;anet.c 

&#x2F;**
 * @param *err
 * @param s
 * @param *sa
 * @param *len
 *&#x2F; 
static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) &#123;
    int fd;
    while(1) &#123;
        &#x2F;&#x2F; 接收socket数据
        &#x2F;&#x2F; fd是socket返回的socket，指向的定义的SOCKADDR_IN 结构体指针，指针的大小
        fd &#x3D; accept(s,sa,len);
        &#x2F;&#x2F; ...
        break;
    &#125;
    return fd;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="2-2-2-接收公共处理器-acceptCommonHandler"><a href="#2-2-2-接收公共处理器-acceptCommonHandler" class="headerlink" title="(2.2.2) 接收公共处理器-acceptCommonHandler"></a>(2.2.2) 接收公共处理器-acceptCommonHandler</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * 
 *&#x2F;
acceptCommonHandler(connCreateAcceptedSocket(cfd),0,cip);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c

&#x2F;**
 * @param *conn
 * @param flags
 * @param *ip 
 *&#x2F;
static void acceptCommonHandler(connection *conn, int flags, char *ip) &#123;
    client *c;
    &#x2F;&#x2F; 创建redisClient对象
    c &#x3D; createClient(conn)

    &#x2F;&#x2F; 建立连接 
    connAccept(conn, clientAcceptHandler)
&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2-2-2-1-connCreateAcceptedSocket"><a href="#2-2-2-1-connCreateAcceptedSocket" class="headerlink" title="(2.2.2.1) connCreateAcceptedSocket()"></a>(2.2.2.1) connCreateAcceptedSocket()</h4><p> conn是怎么创建的 </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;connection.c

&#x2F;**
 * @param fd
 *&#x2F; 
connection *connCreateAcceptedSocket(int fd) &#123;
    &#x2F;&#x2F; 创建连接
    connection *conn &#x3D; connCreateSocket();
    &#x2F;&#x2F; 
    conn-&gt;fd &#x3D; fd;
    &#x2F;&#x2F; 设置连接状态为接收中
    conn-&gt;state &#x3D; CONN_STATE_ACCEPTING;
    return conn;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;connection.h

&#x2F;**
 * 连接结构体
 *&#x2F; 
struct connection &#123;
    ConnectionType *type;  &#x2F;&#x2F; 连接类型 在后面会用到
    ConnectionState state; &#x2F;&#x2F; 连接状态
    short int flags;       
    short int refs; 
    int last_errno;
    void *private_data;    &#x2F;&#x2F; 私有数据
    ConnectionCallbackFunc conn_handler;  &#x2F;&#x2F; 连接处理器
    ConnectionCallbackFunc write_handler; &#x2F;&#x2F; 写处理器
    ConnectionCallbackFunc read_handler;  &#x2F;&#x2F; 读处理器
    int fd;  &#x2F;&#x2F; 
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>






<h4 id="2-2-2-2-创建redisClient对象-createClient"><a href="#2-2-2-2-创建redisClient对象-createClient" class="headerlink" title="(2.2.2.2) 创建redisClient对象-createClient()"></a>(2.2.2.2) 创建redisClient对象-createClient()</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c

&#x2F;**
 * @param *conn
 *&#x2F;
client *createClient(connection *conn) &#123;
    &#x2F;&#x2F; 为用户连接创建client结构体
    client *c &#x3D; zmalloc(sizeof(client));

    if (conn) &#123;
        &#x2F;&#x2F; ... 处理连接

        &#x2F;&#x2F; 注册读事件处理器，等连接可读时调用   回调函数是readQueryFromClient 
        connSetReadHandler(conn, readQueryFromClient);
        &#x2F;&#x2F; 会把新创建的client结构体放到 conn结构体的private_data字段里
        connSetPrivateData(conn, c);
        
    &#125;

    &#x2F;&#x2F; 设置client的一些参数
    selectDb(c,0);
    uint64_t client_id &#x3D; ++server.next_client_id;
    c-&gt;id &#x3D; client_id;
    c-&gt;resp &#x3D; 2;
    c-&gt;conn &#x3D; conn;
    &#x2F;&#x2F; ...

    return c;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>  client结构体主要属性 </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;server.h

typedef struct client &#123;
    uint64_t id;            &#x2F;* 客户端增量唯一ID *&#x2F;
    connection *conn;       &#x2F;** 连接 *&#x2F;
    int resp;               &#x2F;* 响应协议版本 可能是2或3 *&#x2F;
    redisDb *db;            &#x2F;* 指向当前选中的Db *&#x2F;
    robj *name;             &#x2F;* 由客户端设置的名称 *&#x2F;
    sds querybuf;           &#x2F;* 用来累积客户端查询的缓冲区 *&#x2F;
    size_t qb_pos;          &#x2F;* querybuf中读取到的位置 *&#x2F;

    &#x2F;&#x2F; ... 省略部分字段 
    
    &#x2F;* Response buffer *&#x2F;
    int bufpos;    &#x2F;&#x2F; 
    char buf[PROTO_REPLY_CHUNK_BYTES];    &#x2F;&#x2F; 
&#125; client;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;connection.h 

&#x2F;* 
 * 注册读事件处理器，等连接可读时调用 
 * 
 * @param *conn
 * @param func ConnectionCallbackFunc类型的回调函数
 *&#x2F;
static inline int connSetReadHandler(connection *conn, ConnectionCallbackFunc func) &#123;
    return conn-&gt;type-&gt;set_read_handler(conn, func);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2-2-2-3-接收请求-connAccept"><a href="#2-2-2-3-接收请求-connAccept" class="headerlink" title="(2.2.2.3) 接收请求-connAccept()"></a>(2.2.2.3) 接收请求-connAccept()</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* The connection module does not deal with listening and accepting sockets,
 * so we assume we have a socket when an incoming connection is created.
 *
 * The fd supplied should therefore be associated with an already accept()ed
 * socket.
 *
 * connAccept() may directly call accept_handler(), or return and call it
 * at a later time. This behavior is a bit awkward but aims to reduce the need
 * to wait for the next event loop, if no additional handshake is required.
 *
 * IMPORTANT: accept_handler may decide to close the connection, calling connClose().
 * To make this safe, the connection is only marked with CONN_FLAG_CLOSE_SCHEDULED
 * in this case, and connAccept() returns with an error.
 *
 * connAccept() callers must always check the return value and on error (C_ERR)
 * a connClose() must be called.
 *
 * @param *conn 连接
 * @param accept_handler 接收处理器 是一个回调函数 ConnectionCallbackFunc
 *&#x2F;
static inline int connAccept(connection *conn, ConnectionCallbackFunc accept_handler) &#123;
    return conn-&gt;type-&gt;accept(conn, accept_handler);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p> conn-&gt;type 对应 ConnectionType结构体</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;connection.h 

typedef struct ConnectionType &#123;
    void (*ae_handler)(struct aeEventLoop *el, int fd, void *clientData, int mask);
    int (*connect)(struct connection *conn, const char *addr, int port, const char *source_addr, ConnectionCallbackFunc connect_handler);
    int (*write)(struct connection *conn, const void *data, size_t data_len);
    int (*read)(struct connection *conn, void *buf, size_t buf_len);
    void (*close)(struct connection *conn);
    int (*accept)(struct connection *conn, ConnectionCallbackFunc accept_handler);
    int (*set_write_handler)(struct connection *conn, ConnectionCallbackFunc handler, int barrier);
    int (*set_read_handler)(struct connection *conn, ConnectionCallbackFunc handler);
    const char *(*get_last_error)(struct connection *conn);
    int (*blocking_connect)(struct connection *conn, const char *addr, int port, long long timeout);
    ssize_t (*sync_write)(struct connection *conn, char *ptr, ssize_t size, long long timeout);
    ssize_t (*sync_read)(struct connection *conn, char *ptr, ssize_t size, long long timeout);
    ssize_t (*sync_readline)(struct connection *conn, char *ptr, ssize_t size, long long timeout);
    int (*get_type)(struct connection *conn);
&#125; ConnectionType;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">file: src&#x2F;networking.c 

&#x2F;**
 * @param *conn
 *&#x2F; 
void clientAcceptHandler(connection *conn) &#123;
    &#x2F;&#x2F;
    client *c &#x3D; connGetPrivateData(conn);
    &#x2F;&#x2F;
    moduleFireServerEvent(REDISMODULE_EVENT_CLIENT_CHANGE,
                          REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED,
                          c);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<br>


   


<h2 id="2-3-从连接的socket读取客户端发送的数据-recv-read"><a href="#2-3-从连接的socket读取客户端发送的数据-recv-read" class="headerlink" title="(2.3) 从连接的socket读取客户端发送的数据(recv/read)"></a>(2.3) 从连接的socket读取客户端发送的数据(recv/read)</h2><p>  上一步监听后，等到client向redisServer发送的数据到达，会触发设置的回调方法<code>readQueryFromClient</code>，redisServer会调用<code>readQueryFromClient()</code>方法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c

&#x2F;**
 * @param *conn
 *&#x2F; 
void readQueryFromClient(connection *conn) &#123;
    &#x2F;&#x2F; 从连接的私有数据获取client  &#x2F;&#x2F; 在创建连接时把client放到了connection的private_data字段
    client *c &#x3D; connGetPrivateData(conn);

    &#x2F;&#x2F; 

    &#x2F;&#x2F; 客户端输入缓冲区中有更多的数据，请继续解析它，以防检查是否有要执行的完整命令。 
    processInputBuffer(c);    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="2-4-处理读到的数据"><a href="#2-4-处理读到的数据" class="headerlink" title="(2.4) 处理读到的数据"></a>(2.4) 处理读到的数据</h2><p>  从输入缓冲区读到数据后，下面就开始处理数据</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c

&#x2F;* This function is called every time, in the client structure &#39;c&#39;, there is
 * more query buffer to process, because we read more data from the socket
 * or because a client was blocked and later reactivated, so there could be
 * pending query buffer, already representing a full command, to process. *&#x2F;
void processInputBuffer(client *c) &#123;

    &#x2F;&#x2F; ...

    processCommandAndResetClient(c);
&#125;    


&#x2F;* This function calls processCommand(), but also performs a few sub tasks
 * for the client that are useful in that context:
 *
 * 1. It sets the current client to the client &#39;c&#39;.
 * 2. calls commandProcessed() if the command was handled.
 *
 * The function returns C_ERR in case the client was freed as a side effect
 * of processing the command, otherwise C_OK is returned. *&#x2F;
int processCommandAndResetClient(client *c) &#123;
    int deadclient &#x3D; 0;
    server.current_client &#x3D; c;

    &#x2F;&#x2F; 处理命令
    if (processCommand(c) &#x3D;&#x3D; C_OK) &#123;
        commandProcessed(c);
    &#125;
    
    return deadclient ? C_ERR : C_OK;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;server.c

&#x2F;**
 * 处理各种命令 get set del exits quit lpush sadd  等
 *
 * @param *c  
 *&#x2F;
int processCommand(client *c) &#123;

    &#x2F;&#x2F; 查找命令，并进行命令合法性检查，以及命令参数个数检查
    &#x2F;* Now lookup the command and check ASAP about trivial error conditions
     * such as wrong arity, bad command name and so forth. *&#x2F;
    c-&gt;cmd &#x3D; c-&gt;lastcmd &#x3D; lookupCommand(c-&gt;argv[0]-&gt;ptr);


    &#x2F;&#x2F; ... 省略其他命令处理逻辑 


    &#x2F;&#x2F; 处理命令
    &#x2F;* Exec the command *&#x2F;
    if (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;
        c-&gt;cmd-&gt;proc !&#x3D; execCommand &amp;&amp; c-&gt;cmd-&gt;proc !&#x3D; discardCommand &amp;&amp;
        c-&gt;cmd-&gt;proc !&#x3D; multiCommand &amp;&amp; c-&gt;cmd-&gt;proc !&#x3D; watchCommand)
    &#123; &#x2F;&#x2F; 如果是 MULTI 事务，则入队
        queueMultiCommand(c);
        addReply(c,shared.queued);
    &#125; else &#123; &#x2F;&#x2F; 调用 call 直接处理
        call(c,CMD_CALL_FULL);
        c-&gt;woff &#x3D; server.master_repl_offset;
        if (listLength(server.ready_keys))
            handleClientsBlockedOnKeys();
    &#125;
    return C_OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;server.c

&#x2F;**
 * 根据key查找值
 * 
 * @param name 
 *&#x2F;
struct redisCommand *lookupCommand(sds name) &#123;
    &#x2F;&#x2F; 
    return dictFetchValue(server.commands, name);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;**
 * call() 是 Redis 执行命令的核心。
 *
 * @param *c
 * @param flags 
 *&#x2F;
void call(client *c, int flags) &#123;

    &#x2F;&#x2F; 要执行的redis命令
    struct redisCommand *real_cmd &#x3D; c-&gt;cmd;

    &#x2F;&#x2F; 调用命令处理函数   
    c-&gt;cmd-&gt;proc(c);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  proc对应的command有以下几种</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 *
 *&#x2F;
struct redisCommand redisCommandTable[] &#x3D; &#123;
    &#123;&quot;module&quot;,moduleCommand,-2,
     &quot;admin no-script&quot;,
     0,NULL,0,0,0,0,0,0&#125;,

    &#123;&quot;get&quot;,getCommand,2,
     &quot;read-only fast @string&quot;,
     0,NULL,1,1,1,0,0,0&#125;,

    &#x2F;* Note that we can&#39;t flag set as fast, since it may perform an
     * implicit DEL of a large key. *&#x2F;
    &#123;&quot;set&quot;,setCommand,-3,
     &quot;write use-memory @string&quot;,
     0,NULL,1,1,1,0,0,0&#125;,

    &#123;&quot;setnx&quot;,setnxCommand,3,
     &quot;write use-memory fast @string&quot;,
     0,NULL,1,1,1,0,0,0&#125;,

    &#123;&quot;setex&quot;,setexCommand,4,
     &quot;write use-memory @string&quot;,
     0,NULL,1,1,1,0,0,0&#125;,
   
    &#x2F;&#x2F; .. 

    &#123;&quot;rpush&quot;,rpushCommand,-3,
     &quot;write use-memory fast @list&quot;,
     0,NULL,1,1,1,0,0,0&#125;,

    &#123;&quot;lpush&quot;,lpushCommand,-3,
     &quot;write use-memory fast @list&quot;,
     0,NULL,1,1,1,0,0,0&#125;,
    
    &#x2F;&#x2F; ... 

    &#123;&quot;sadd&quot;,saddCommand,-3,
     &quot;write use-memory fast @set&quot;,
     0,NULL,1,1,1,0,0,0&#125;,

  
     &#x2F;&#x2F; ... 

    &#123;&quot;zadd&quot;,zaddCommand,-4,
     &quot;write use-memory fast @sortedset&quot;,
     0,NULL,1,1,1,0,0,0&#125;,
      
    &#x2F;&#x2F; ... 

    &#123;&quot;stralgo&quot;,stralgoCommand,-2,
     &quot;read-only @string&quot;,
     0,lcsGetKeys,0,0,0,0,0,0&#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>  如果命令是get，其对应的命令处理函数就是 getCommand</p>
<h3 id="2-4-1-getCommand"><a href="#2-4-1-getCommand" class="headerlink" title="(2.4.1) getCommand"></a>(2.4.1) getCommand</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: t_string.c 

&#x2F;**
 * @param *c
 *&#x2F;
void getCommand(client *c) &#123;
    getGenericCommand(c);
&#125;

int getGenericCommand(client *c) &#123;
    robj *o;

    &#x2F;&#x2F; 查找key
    if ((o &#x3D; lookupKeyReadOrReply(c,c-&gt;argv[1],shared.null[c-&gt;resp])) &#x3D;&#x3D; NULL)
        return C_OK;

    &#x2F;&#x2F; 找到key对应的值了
    if (o-&gt;type !&#x3D; OBJ_STRING) &#123; &#x2F;&#x2F; key的对象类型不是string类型 返回错误
        addReply(c,shared.wrongtypeerr);
        return C_ERR;
    &#125; else &#123; &#x2F;&#x2F; key的对象类型是string类型
        &#x2F;&#x2F; 将结果添加到输出缓冲区中
        addReplyBulk(c,o);
        return C_OK;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c 

&#x2F;* Add a Redis Object as a bulk reply *&#x2F;
void addReplyBulk(client *c, robj *obj) &#123;
    addReplyBulkLen(c,obj);
    addReply(c,obj);
    addReply(c,shared.crlf);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="2-4-2-setCommand"><a href="#2-4-2-setCommand" class="headerlink" title="(2.4.2) setCommand"></a>(2.4.2) setCommand</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src.t_string.c

&#x2F;**
 * 
 * @param *c
 * @param flags
 * @param *key
 * @param *val
 * @param *expire
 * @param unit
 * @param *ok_reply
 * @param *abort_reply
 *&#x2F;
void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) &#123;
    &#x2F;&#x2F; 64位精度整数 
    long long milliseconds &#x3D; 0; &#x2F;* initialized to avoid any harmness warning *&#x2F;

    if (expire) &#123;
        if (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, NULL) !&#x3D; C_OK)
            return;
        if (milliseconds &lt;&#x3D; 0) &#123;
            addReplyErrorFormat(c,&quot;invalid expire time in %s&quot;,c-&gt;cmd-&gt;name);
            return;
        &#125;
        if (unit &#x3D;&#x3D; UNIT_SECONDS) milliseconds *&#x3D; 1000;
    &#125;

    if ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) !&#x3D; NULL) ||
        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) &#x3D;&#x3D; NULL))
    &#123;
        addReply(c, abort_reply ? abort_reply : shared.null[c-&gt;resp]);
        return;
    &#125;
    genericSetKey(c,c-&gt;db,key,val,flags &amp; OBJ_SET_KEEPTTL,1);
    server.dirty++;
    if (expire) setExpire(c,c-&gt;db,key,mstime()+milliseconds);
    notifyKeyspaceEvent(NOTIFY_STRING,&quot;set&quot;,key,c-&gt;db-&gt;id);
    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,
        &quot;expire&quot;,key,c-&gt;db-&gt;id);
    addReply(c, ok_reply ? ok_reply : shared.ok);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="2-5-给客户端返回结果-send"><a href="#2-5-给客户端返回结果-send" class="headerlink" title="(2.5) 给客户端返回结果(send)"></a>(2.5) 给客户端返回结果(send)</h2><p>  无论是执行get命令还是set命令，最后执行完命令都会调用<code>addReply()</code>方法<br>  在<code>addReply</code>方法中做了两件事情:<br>  1、<code>prepareClientToWrite</code> 判断是否需要返回数据，并且将当前 client 添加到等待写返回数据队列中。<br>  2、调用 <code>_addReplyToBuffer</code> 和 <code>_addReplyObjectToList</code> 方法将返回值写入到输出缓冲区中，等待写入 socekt</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c 


&#x2F;* -----------------------------------------------------------------------------
 * 更高级别的函数用于在客户端输出缓冲区上对数据进行排队。
 * 以下函数是命令实现将调用的函数。
 * -------------------------------------------------------------------------- *&#x2F;

&#x2F;* 
 * 将对象“obj”字符串表示添加到客户端输出缓冲区。 
 * 
 * @param *c  redis client  
 * @param *obj  命令执行的结果   类型是redisObject
 *&#x2F;
void addReply(client *c, robj *obj) &#123;

    &#x2F;&#x2F; 判断client是否可以接收新数据 (假客户端不能接收)
    if (prepareClientToWrite(c) !&#x3D; C_OK) return;

    &#x2F;&#x2F; 根据redisobject格式把数据写入缓存
    if (sdsEncodedObject(obj)) &#123; &#x2F;&#x2F; obj如果是row或者embstr格式

        &#x2F;&#x2F; 尝试将应答添加到客户端结构中的静态缓冲区。
        if (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) !&#x3D; C_OK)
            &#x2F;&#x2F; 将回复添加到回复列表中。
            _addReplyProtoToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));  

    &#125; else if (obj-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_INT) &#123; &#x2F;&#x2F; obj 是数字格式

        &#x2F;* 对于整数编码字符串，我们只需使用优化函数将其转换为字符串，并将结果字符串附加到输出缓冲区。 *&#x2F;
        char buf[32];
        &#x2F;&#x2F; 数字转为字符串
        size_t len &#x3D; ll2string(buf,sizeof(buf),(long)obj-&gt;ptr);
        if (_addReplyToBuffer(c,buf,len) !&#x3D; C_OK)
            _addReplyProtoToList(c,buf,len);

    &#125; else &#123;
        serverPanic(&quot;Wrong obj-&gt;encoding in addReply()&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c 

&#x2F;* -----------------------------------------------------------------------------
 * 低级函数用于向输出缓冲区添加更多数据。
 * -------------------------------------------------------------------------- *&#x2F;

&#x2F;** 
 * 尝试将应答添加到客户端结构中的静态缓冲区。
 * 如果缓冲区已满或回复列表不为空，则返回C_ERR，在这种情况下，必须将回复添加到回复列表中。 
 * 
 * @param *c 
 * @param *s 要写入的数据
 * @param len 数据长度
 *&#x2F;
int _addReplyToBuffer(client *c, const char *s, size_t len) &#123;
    &#x2F;&#x2F; 剩余缓冲区大小
    size_t available &#x3D; sizeof(c-&gt;buf)-c-&gt;bufpos;

    if (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) return C_OK;

    &#x2F;* 如果回复列表中已经有内容，则无法向静态缓冲区添加更多内容。 *&#x2F;
    if (listLength(c-&gt;reply) &gt; 0) return C_ERR;

    &#x2F;* 检查缓冲区是否有足够的空间用于此字符串。 *&#x2F;
    if (len &gt; available) return C_ERR;

    &#x2F;&#x2F; 把数据*s(char[]类型) 拷贝到 client对象的Response buffer中
    memcpy(c-&gt;buf+c-&gt;bufpos,s,len);
    &#x2F;&#x2F; 更新已使用缓冲区大小
    c-&gt;bufpos+&#x3D;len;
    return C_OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * 将回复添加到回复列表中。 
 * 注意：对该函数的一些编辑需要转发到AddReplyFromClient。
 * 
 * @param *c 
 * @param *s 要写入的数据
 * @param len 数据长度
 *&#x2F; 
void _addReplyProtoToList(client *c, const char *s, size_t len) &#123;

    &#x2F;&#x2F; 写入回复后关闭
    if (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) return;

    &#x2F;&#x2F; 双向链表尾部
    listNode *ln &#x3D; listLast(c-&gt;reply);
    &#x2F;&#x2F; 链表里存的数据是 clientReplyBlock类型 是一个buf数组，有大小限制
    clientReplyBlock *tail &#x3D; ln? listNodeValue(ln): NULL;

    &#x2F;* Note that &#39;tail&#39; may be NULL even if we have a tail node, because when
     * addReplyDeferredLen() is used, it sets a dummy node to NULL just
     * fo fill it later, when the size of the bulk length is set. *&#x2F;

    &#x2F;* 尽可能追加到尾部字符串。*&#x2F;
    if (tail) &#123;
        &#x2F;* 复制我们可以放入尾部的部分，并将其余部分留给新节点 *&#x2F;
        size_t avail &#x3D; tail-&gt;size - tail-&gt;used;
        &#x2F;&#x2F; *s要复制的部分 (可能是全部，可能是部分)
        size_t copy &#x3D; avail &gt;&#x3D; len? len: avail;
        &#x2F;&#x2F; 复制到buf数组里
        memcpy(tail-&gt;buf + tail-&gt;used, s, copy);
        tail-&gt;used +&#x3D; copy;
        s +&#x3D; copy;
        len -&#x3D; copy;
    &#125;
    
    &#x2F;&#x2F; len&gt;0
    if (len) &#123;
        &#x2F;* 创建一个新节点，确保至少为其分配了 16K *&#x2F;
        size_t size &#x3D; len &lt; PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;
        tail &#x3D; zmalloc(size + sizeof(clientReplyBlock));
        &#x2F;* take over the allocation&#39;s internal fragmentation *&#x2F;
        tail-&gt;size &#x3D; zmalloc_usable(tail) - sizeof(clientReplyBlock);
        tail-&gt;used &#x3D; len;
        memcpy(tail-&gt;buf, s, len);
        listAddNodeTail(c-&gt;reply, tail);
        c-&gt;reply_bytes +&#x3D; tail-&gt;size;
    &#125;

    &#x2F;&#x2F; 缓冲区达到限制后异步关闭客户端
    asyncCloseClientOnOutputBufferLimitReached(c);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="2-5-1-回复列表中的数据什么时候写入到输出缓冲区呢？"><a href="#2-5-1-回复列表中的数据什么时候写入到输出缓冲区呢？" class="headerlink" title="(2.5.1) 回复列表中的数据什么时候写入到输出缓冲区呢？"></a>(2.5.1) 回复列表中的数据什么时候写入到输出缓冲区呢？</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;ae.c 

void aeMain(aeEventLoop *eventLoop) &#123;
    eventLoop-&gt;stop &#x3D; 0;
    &#x2F;&#x2F; 循环
    while (!eventLoop-&gt;stop) &#123;
        &#x2F;&#x2F; 处理事件
        aeProcessEvents(eventLoop, AE_ALL_EVENTS|
                                   AE_CALL_BEFORE_SLEEP|
                                   AE_CALL_AFTER_SLEEP);
    &#125;
&#125;

&#x2F;**
 * 处理事件
 *&#x2F; 
int aeProcessEvents(aeEventLoop *eventLoop, int flags)
&#123;
        &#x2F;&#x2F; 
        if (eventLoop-&gt;beforesleep !&#x3D; NULL &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)
            eventLoop-&gt;beforesleep(eventLoop);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;server.c

&#x2F;* This function gets called every time Redis is entering the
 * main loop of the event driven library, that is, before to sleep
 * for ready file descriptors.
 *
 * Note: This function is (currently) called from two functions:
 * 1. aeMain - The main server loop
 * 2. processEventsWhileBlocked - Process clients during RDB&#x2F;AOF load
 *
 * If it was called from processEventsWhileBlocked we don&#39;t want
 * to perform all actions (For example, we don&#39;t want to expire
 * keys), but we do need to perform some actions.
 *
 * The most important is freeClientsInAsyncFreeQueue but we also
 * call some other low-risk functions. *&#x2F;
void beforeSleep(struct aeEventLoop *eventLoop) &#123;

    &#x2F;* 处理具有挂起的输出缓冲区的写入。 *&#x2F;
    handleClientsWithPendingWritesUsingThreads();
 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c

int handleClientsWithPendingWritesUsingThreads(void) &#123;
    int processed &#x3D; listLength(server.clients_pending_write);
    if (processed &#x3D;&#x3D; 0) return 0; &#x2F;* Return ASAP if there are no clients. *&#x2F;

    &#x2F;* If I&#x2F;O threads are disabled or we have few clients to serve, don&#39;t
     * use I&#x2F;O threads, but thejboring synchronous code. *&#x2F;
    if (server.io_threads_num &#x3D;&#x3D; 1 || stopThreadedIOIfNeeded()) &#123;
        return handleClientsWithPendingWrites();
    &#125;

    &#x2F;* Start threads if needed. *&#x2F;
    if (!server.io_threads_active) startThreadedIO();

    if (tio_debug) printf(&quot;%d TOTAL WRITE pending clients\n&quot;, processed);

    &#x2F;* Distribute the clients across N different lists. *&#x2F;
    listIter li;
    listNode *ln;
    &#x2F;* 把server.clients_pending_write链表 赋值 给迭代器&amp;li *&#x2F;
    listRewind(server.clients_pending_write,&amp;li);
    int item_id &#x3D; 0;
    &#x2F;&#x2F; 遍历链表 server.clients_pending_write
    while((ln &#x3D; listNext(&amp;li))) &#123;
        client *c &#x3D; listNodeValue(ln);
        c-&gt;flags &amp;&#x3D; ~CLIENT_PENDING_WRITE;

        &#x2F;&#x2F; &amp; 状态&#x3D;尽快关闭
        if (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) &#123;
            &#x2F;&#x2F; 删除双向链表里的当前节点
            listDelNode(server.clients_pending_write, ln);
            continue;
        &#125;

        int target_id &#x3D; item_id % server.io_threads_num;
        &#x2F;&#x2F; 把c添加到io_threads_list[target_id]链表尾部  后面会用到
        listAddNodeTail(io_threads_list[target_id],c);
        item_id++;
    &#125;


    &#x2F;* 把io_threads_list[0]链表 赋值 给迭代器&amp;li *&#x2F;
    listRewind(io_threads_list[0],&amp;li);
    &#x2F;&#x2F; 遍历链表 io_threads_list[0]
    while((ln &#x3D; listNext(&amp;li))) &#123;
        client *c &#x3D; listNodeValue(ln);
        &#x2F;&#x2F; 将client的数据发送出去
        writeToClient(c,0);
    &#125;
    listEmpty(io_threads_list[0]);


    &#x2F;* 把server.clients_pending_write链表 赋值 给迭代器&amp;li *&#x2F;
    listRewind(server.clients_pending_write,&amp;li);
    &#x2F;&#x2F; 遍历链表 server.clients_pending_write
    while((ln &#x3D; listNext(&amp;li))) &#123;
        &#x2F;&#x2F; 获取节点
        client *c &#x3D; listNodeValue(ln);

        &#x2F;* 如果某些客户端中存在挂起的写入，安装写入处理程序。*&#x2F;
        &#x2F;&#x2F; 如果一次发送不完则准备下一次发送
        if (clientHasPendingReplies(c) &amp;&amp;
                connSetWriteHandler(c-&gt;conn, sendReplyToClient) &#x3D;&#x3D; AE_ERR)
        &#123;
            freeClientAsync(c);
        &#125;
    &#125;
    listEmpty(server.clients_pending_write);

    return processed;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="2-5-2-写事件处理器-sendReplyToClient"><a href="#2-5-2-写事件处理器-sendReplyToClient" class="headerlink" title="(2.5.2) 写事件处理器-sendReplyToClient"></a>(2.5.2) 写事件处理器-sendReplyToClient</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c 

&#x2F;**
 * 写事件处理器 
 * 仅仅发送数据到client
 * 
 * Write event handler. Just send data to the client.
 *&#x2F;
void sendReplyToClient(connection *conn) &#123;
    client *c &#x3D; connGetPrivateData(conn);

    &#x2F;&#x2F; 
    writeToClient(c,1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="2-5-3-把数据写入客户端的输出缓冲区"><a href="#2-5-3-把数据写入客户端的输出缓冲区" class="headerlink" title="(2.5.3) 把数据写入客户端的输出缓冲区"></a>(2.5.3) 把数据写入客户端的输出缓冲区</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;networking.c

&#x2F;**
 * 把数据写入客户端的输出缓冲区 
 * 
 *  Write data in output buffers to client. Return C_OK if the client
 * is still valid after the call, C_ERR if it was freed because of some
 * error.  If handler_installed is set, it will attempt to clear the
 * write event.
 *
 * This function is called by threads, but always with handler_installed
 * set to 0. So when handler_installed is set to 0 the function must be
 * thread safe. *&#x2F;
int writeToClient(client *c, int handler_installed) &#123;
    &#x2F;* Update total number of writes on server *&#x2F;
    server.stat_total_writes_processed++;

    ssize_t nwritten &#x3D; 0, totwritten &#x3D; 0;
    size_t objlen;
    clientReplyBlock *o;

    while(clientHasPendingReplies(c)) &#123;

        if (c-&gt;bufpos &gt; 0) &#123; &#x2F;&#x2F; 缓冲区有数据
            &#x2F;&#x2F; 把缓冲区数据写入socket
            nwritten &#x3D; connWrite(c-&gt;conn,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);
            
        &#125; else &#123; &#x2F;&#x2F; 处理待发送链表
            o &#x3D; listNodeValue(listFirst(c-&gt;reply));
            objlen &#x3D; o-&gt;used;

            if (objlen &#x3D;&#x3D; 0) &#123;
                c-&gt;reply_bytes -&#x3D; o-&gt;size;
                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));
                continue;
            &#125;

            &#x2F;&#x2F; 把链表节点里的数据写入socket
            nwritten &#x3D; connWrite(c-&gt;conn, o-&gt;buf + c-&gt;sentlen, objlen - c-&gt;sentlen);
            
        &#125;
    &#125;
    return C_OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;connection.h 

&#x2F;**
 *  把数据写入到连接里
 *&#x2F;
static inline int connWrite(connection *conn, const void *data, size_t data_len) &#123;
    return conn-&gt;type-&gt;write(conn, data, data_len);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<br>
<br>




<h1 id="3-RedisServer里IO多路复用代码详解"><a href="#3-RedisServer里IO多路复用代码详解" class="headerlink" title="(3) RedisServer里IO多路复用代码详解"></a>(3) RedisServer里IO多路复用代码详解</h1><p>  在 <code>initServer</code> 这个函数内，Redis 做了这么三件重要的事情。<br>1、创建一个 epoll 对象<br>2、对配置的端口进行监听(listen)<br>3、把 listen socket 让 epoll 给管理起来</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;file: src&#x2F;server.c

void initServer(void) &#123;

    &#x2F;&#x2F; 2.1 创建 epoll
    server.el &#x3D; aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);
    
    &#x2F;&#x2F; 2.2 绑定监听服务端口   
    &#x2F;&#x2F; Open the TCP listening socket for the user commands.
    listenToPort(server.port,server.ipfd,&amp;server.ipfd_count)

    &#x2F;&#x2F; 2.3 注册accept事件处理器  
    &#x2F;&#x2F; Create an event handler for accepting new connections in TCP and Unix domain sockets.
    for (j &#x3D; 0; j &lt; server.ipfd_count; j++) &#123;
        aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,
            acceptTcpHandler,NULL)
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3-1-创建epoll-aeCreateEventLoop"><a href="#3-1-创建epoll-aeCreateEventLoop" class="headerlink" title="(3.1) 创建epoll-aeCreateEventLoop"></a>(3.1) 创建epoll-aeCreateEventLoop</h2><p>  <strong>redisServer结构</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;server.h 

&#x2F;&#x2F; redisServer结构体
struct redisServer &#123;

    &#x2F;&#x2F; ... 省略部分代码

    aeEventLoop *el;

    &#x2F;&#x2F; ... 省略部分代码
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>  <strong>aeEventLoop结构</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;ae.h

&#x2F;&#x2F; 基于事件的程序的状态 
&#x2F;* State of an event based program *&#x2F;
typedef struct aeEventLoop &#123;
    int maxfd;   &#x2F;&#x2F; 当前注册的最大文件描述符
    int setsize; &#x2F;&#x2F; 跟踪的最大文件描述符数
    long long timeEventNextId;
    time_t lastTime;     &#x2F;* Used to detect system clock skew *&#x2F;
    aeFileEvent *events; &#x2F;&#x2F; 注册事件数组的指针 指向aeFileEvent数组   
    aeFiredEvent *fired; &#x2F;&#x2F; 就绪事件数组的指针  指向aeFiredEvent数组
    aeTimeEvent *timeEventHead;  &#x2F;&#x2F; 时间事件
    int stop;
    void *apidata; &#x2F;&#x2F; 指向aeApiState结构体  创建的epoll对象就在aeApiState-&gt;epfd
    aeBeforeSleepProc *beforesleep; &#x2F;&#x2F; 在事件处理前执行的函数 
    aeBeforeSleepProc *aftersleep; &#x2F;&#x2F; 在事件处理后执行的函数
    int flags;
&#125; aeEventLoop;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;ae.h 

&#x2F;&#x2F; 文件事件结构
&#x2F;* File event structure *&#x2F;
typedef struct aeFileEvent &#123;
    int mask;    &#x2F;&#x2F; 标记 可读&#x2F;可写&#x2F;屏障
    aeFileProc *rfileProc;  &#x2F;&#x2F; 写事件回调
    aeFileProc *wfileProc;  &#x2F;&#x2F; 读事件回调
    void *clientData;       &#x2F;&#x2F; 扩展数据
&#125; aeFileEvent;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  Redis 在操作系统提供的 epoll 对象基础上又封装了一个 eventLoop 出来，所以创建的时候是先申请和创建 eventLoop。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;ae.c 

&#x2F;**
 * 创建aeEventLoop结构体
 *
 * @param setsize
 *&#x2F;
aeEventLoop *aeCreateEventLoop(int setsize) &#123;

    aeEventLoop *eventLoop;
    &#x2F;&#x2F; ... 省略部分代码 

    eventLoop &#x3D; zmalloc(sizeof(*eventLoop))
    &#x2F;&#x2F; 将来的各种回调事件就都会存在这里
    &#x2F;&#x2F; eventLoop-&gt;events是一个指针 指向数组 元素类型:aeFileEvent  大小:setsize
    eventLoop-&gt;events &#x3D; zmalloc(sizeof(aeFileEvent)*setsize);
    eventLoop-&gt;fired &#x3D; zmalloc(sizeof(aeFiredEvent)*setsize);

    &#x2F;&#x2F; ... 省略部分代码

    &#x2F;&#x2F; 创建epoll
    aeApiCreate(eventLoop)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file:  src&#x2F;ae_epoll.c 

static int aeApiCreate(aeEventLoop *eventLoop) &#123;
    aeApiState *state &#x3D; zmalloc(sizeof(aeApiState));

    &#x2F;&#x2F; ... 省略部分代码
 
    &#x2F;&#x2F; 真正创建epoll
    &#x2F;&#x2F; 调linux epoll_create()函数 创建epoll
    state-&gt;epfd &#x3D; epoll_create(2024); &#x2F;* 1024 is just a hint for the kernel *&#x2F;
    
    &#x2F;&#x2F; ... 省略部分代码

    eventLoop-&gt;apidata &#x3D; state;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-2-注册事件及回调函数-aeCreateFileEvent"><a href="#3-2-注册事件及回调函数-aeCreateFileEvent" class="headerlink" title="(3.2) 注册事件及回调函数-aeCreateFileEvent"></a>(3.2) 注册事件及回调函数-aeCreateFileEvent</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file:  src&#x2F;ae.c

&#x2F;**
 * @param *eventLoop
 * @param fd 
 * @param mask 0:未注册事件  1:描述符可读时触发  2:描述符可写时触发  3:
 * @param *proc aeFileProc类型  入参传的是 acceptTcpHandler函数 回调时会用到这个函数 
 * @param *clientData
 *&#x2F; 
int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
        aeFileProc *proc, void *clientData)
&#123;
    if (fd &gt;&#x3D; eventLoop-&gt;setsize) &#123;
        errno &#x3D; ERANGE;
        return AE_ERR;
    &#125;

    &#x2F;&#x2F; 从aeFileEvent事件数组里取出一个文件事件结构
    aeFileEvent *fe &#x3D; &amp;eventLoop-&gt;events[fd];

    &#x2F;&#x2F; 监听指定fd的指定事件
    if (aeApiAddEvent(eventLoop, fd, mask) &#x3D;&#x3D; -1)
        return AE_ERR;

    &#x2F;&#x2F; 设置文件事件类型 以及事件的处理器
    fe-&gt;mask |&#x3D; mask;
    if (mask &amp; AE_READABLE) fe-&gt;rfileProc &#x3D; proc;  &#x2F;&#x2F; 设置读事件回调
    if (mask &amp; AE_WRITABLE) fe-&gt;wfileProc &#x3D; proc;  &#x2F;&#x2F; 设置写事件回调

    &#x2F;&#x2F; 私有数据
    fe-&gt;clientData &#x3D; clientData;

    if (fd &gt; eventLoop-&gt;maxfd)
        eventLoop-&gt;maxfd &#x3D; fd;

    return AE_OK;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;file: src&#x2F;ae_epoll.c

&#x2F;&#x2F; 添加事件
static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) &#123;
    aeApiState *state &#x3D; eventLoop-&gt;apidata;
    struct epoll_event ee &#x3D; &#123;0&#125;; &#x2F;* avoid valgrind warning *&#x2F;
    &#x2F;* If the fd was already monitored for some event, we need a MOD
     * operation. Otherwise we need an ADD operation. *&#x2F;
    int op &#x3D; eventLoop-&gt;events[fd].mask &#x3D;&#x3D; AE_NONE ?
            EPOLL_CTL_ADD : EPOLL_CTL_MOD;

    &#x2F;&#x2F; ... 

    &#x2F;&#x2F; epoll_ctl 添加事件 
    epoll_ctl(state-&gt;epfd,op,fd,&amp;ee);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  这个函数其实就是对 epoll_ctl 的一个封装。主要就是实际执行 epoll_ctl EPOLL_CTL_ADD。</p>
<p>每一个 eventLoop-&gt;events 元素都指向一个 aeFileEvent 对象。<br>在这个对象上，设置了三个关键东西<br>  rfileProc：读事件回调<br>  wfileProc：写事件回调<br>  clientData：一些额外的扩展数据</p>
<p>将来 当 <code>epoll_wait</code> 发现某个 <code>fd</code> 上有事件发生的时候，这样 redis 首先根据 fd 到 eventLoop-&gt;events 中查找 aeFileEvent 对象，然后再看 rfileProc、wfileProc 就可以找到读、写回调处理函数。</p>
<p>listen fd 对应的读回调函数 rfileProc 事实上就被设置成了 acceptTcpHandler，私有数据 client_data 也为 null。</p>
<h2 id="3-3-获取就绪socket并处理事件-aeMain"><a href="#3-3-获取就绪socket并处理事件-aeMain" class="headerlink" title="(3.3) 获取就绪socket并处理事件-aeMain()"></a>(3.3) 获取就绪socket并处理事件-aeMain()</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;ae.c

&#x2F;**
 * 循环接收请求
 * 
 * @param *eventLoop
 *&#x2F; 
void aeMain(aeEventLoop *eventLoop) &#123;
    eventLoop-&gt;stop &#x3D; 0;
    &#x2F;&#x2F; 循环
    while (!eventLoop-&gt;stop) &#123;
        &#x2F;&#x2F; 处理事件 
        aeProcessEvents(eventLoop, AE_ALL_EVENTS|
                                   AE_CALL_BEFORE_SLEEP|
                                   AE_CALL_AFTER_SLEEP);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 处理事件   返回处理完的事件个数

0 不做任何处理
1 AE_FILE_EVENTS  处理文件事件
2 AE_TIME_EVENTS  处理时间事件 
3 AE_ALL_EVENTS   所有事件 
4 AE_DONT_WAIT 
8 AE_CALL_BEFORE_SLEEP 
16 AE_CALL_AFTER_SLEEP 

int aeProcessEvents(aeEventLoop *eventLoop, int flags)
&#123;
    int processed &#x3D; 0, numevents;

        struct timeval tv, *tvp;

        &#x2F;&#x2F; 如果eventLoop处理前的函数不为空，就执行
        if (eventLoop-&gt;beforesleep !&#x3D; NULL &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)
            eventLoop-&gt;beforesleep(eventLoop);

        &#x2F;&#x2F; 调用多路复用 API，仅在超时或某些事件触发时返回   
        &#x2F;&#x2F; 处理文件事件，阻塞时间由tvp决定 
        numevents &#x3D; aeApiPoll(eventLoop, tvp);

        &#x2F;&#x2F; 处理后的函数不为空
        &#x2F;* After sleep callback. *&#x2F;
        if (eventLoop-&gt;aftersleep !&#x3D; NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)
            eventLoop-&gt;aftersleep(eventLoop);

        for (j &#x3D; 0; j &lt; numevents; j++) &#123;
            &#x2F;&#x2F; 先从eventLoop-&gt;fired[j]获取已就绪事件结构体(aeFiredEvent) 获取fd后 再从eventLoop-&gt;events注册事件里获取对应的事件结构体(aeFileEvent) 
            aeFileEvent *fe &#x3D; &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];
            
            &#x2F;&#x2F; ...

            &#x2F;&#x2F; 如果可读
            if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;
                &#x2F;&#x2F; 调用读事件回调函数 对应 acceptTcpHandler 
                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);
                fired++;
                fe &#x3D; &amp;eventLoop-&gt;events[fd]; &#x2F;* Refresh in case of resize. *&#x2F;
            &#125;

            &#x2F;&#x2F; 如果可写 触发写事件
            if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;
                if (!fired || fe-&gt;wfileProc !&#x3D; fe-&gt;rfileProc) &#123;
                    &#x2F;&#x2F; 调用写事件回调函数 对应 acceptTcpHandler 
                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);
                    fired++;
                &#125;
            &#125;

            processed++;
        &#125;
    
    return processed; &#x2F;* return the number of processed file&#x2F;time events *&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; file: src&#x2F;ae_poll.c 

&#x2F;**
 * 获取就绪事件
 * 
 * @param *eventLoop
 * @param *tvp
 *&#x2F; 
static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123;
    &#x2F;&#x2F; 等待事件
    aeApiState *state &#x3D; eventLoop-&gt;apidata;
    int retval, numevents &#x3D; 0;

    &#x2F;&#x2F; 调linux epoll_wait函数来获取已就绪socket
    retval &#x3D; epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,
            tvp ? (tvp-&gt;tv_sec*1000 + tvp-&gt;tv_usec&#x2F;1000) : -1);

    &#x2F;&#x2F; ...

    return numevents;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  aeProcessEvents 就是调用 epoll_wait 来获取就绪socket 。<br>  当发现有某个socket上数据就绪以后，则调用事先注册的事件处理器函数 rfileProc 和 wfileProc。</p>
<h1 id="4-RedisServer-IO模型流程概览"><a href="#4-RedisServer-IO模型流程概览" class="headerlink" title="(4) RedisServer-IO模型流程概览"></a>(4) RedisServer-IO模型流程概览</h1><p>  <img src="/img/database/redis/io-model/redis-io-model-detail.png" alt="redisServer-IO模型流程概览"></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="Redis有哪些潜在的性能瓶颈"><a href="#Redis有哪些潜在的性能瓶颈" class="headerlink" title="Redis有哪些潜在的性能瓶颈"></a>Redis有哪些潜在的性能瓶颈</h2><p>Redis单线程处理IO请求性能瓶颈主要包括2个方面：</p>
<p>1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。<br>2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。</p>
<p>耗时的操作包括以下几种：<br>  a、操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；<br>  b、使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；<br>  c、大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；<br>  d、淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；<br>  e、AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；<br>  f、主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；</p>
<p>针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。</p>
<p>针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。</p>
<h2 id="Redis-6-0版本为什么又引入了多线程"><a href="#Redis-6-0版本为什么又引入了多线程" class="headerlink" title="Redis 6.0版本为什么又引入了多线程"></a>Redis 6.0版本为什么又引入了多线程</h2><p>Redis 的瓶颈不在 CPU ，而在内存和网络，内存不够可以增加内存或通过数据结构等进行优化<br>但 Redis 的网络 IO 的读写占用了发部分 CPU 的时间，如果可以把网络处理改成多线程的方式，性能会有很大提升<br>所以总结下 Redis 6.0 版本引入多线程有两个原因<br>1.充分利用服务器的多核资源<br>2.多线程分摊 Redis 同步 IO 读写负荷</p>
<p>执行命令还是由单线程顺序执行，只是处理网络数据读写采用了多线程，而且 IO 线程要么同时读 Socket ，要么同时写 Socket ，不会同时读写</p>
<br>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2y60cxUjaaE2pWSdCBX1lA">深度解析单线程的 Redis 如何做到每秒数万 QPS 的超高处理能力！</a><br>[2] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358120269">epoll源码分析以及在Redis中的实现</a><br>[3] <a target="_blank" rel="noopener" href="https://blog.csdn.net/junlon2006/article/details/101438339">Redis5.0.5源码解析 – 多路复用模型</a><br>[4] <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/270474">03 | 高性能IO模型：为什么单线程Redis能那么快？</a><br>[5] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qqTgnG3ndeUiZXdnmzQUfQ">Redis多线程架构的演进</a><br>[6] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/U05J_iF_0CIP5Vs_H9hLNA">性能突出的Redis是咋使用epoll的？</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="WKQ 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="WKQ 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/io/" rel="tag"># io</a>
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/01/02/redis-index-model/" rel="prev" title="Redis索引模型">
                  <i class="fa fa-chevron-left"></i> Redis索引模型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/01/15/redis-rdb/" rel="next" title="Redis RDB">
                  Redis RDB <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WKQ</span>
</div>
<div class="busuanzi-count">
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
